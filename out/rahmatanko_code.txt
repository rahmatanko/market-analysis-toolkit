
==============================
FILE: CSVReader.cpp
==============================
#include "CSVReader.h"
#include <iostream>
#include <fstream>
#include <sstream>

// read the market CSV file and convert each line to OrderBookEntry
// starter code
std::vector<OrderBookEntry> CSVReader::readMarketCSV(const std::string& filename)
{
    std::vector<OrderBookEntry> entries; // this will hold all the entries from the CSV

    std::ifstream csvFile{filename}; // open the file
    std::string line;
    int lineNum = 0; // keep track of the line number
    if (csvFile.is_open())
    {
        while(std::getline(csvFile, line)) // read line by line
        {
            ++lineNum;
            std::vector<std::string> tokens = tokenise(line, ',');
            
            // skip malformed lines
            if (tokens.size() != 5) {
                std::cout << "CSVReader::readMarketCSV bad data (wrong token count) at line " << lineNum << std::endl;
                continue; // skip this line
            }

            try {
                // convert line to tokens, then tokens to OrderBookEntry
                OrderBookEntry obe = stringsToOBE(tokens);
                entries.push_back(obe); // add to our vector
            } catch(const std::exception& e)
            {
                // if the line has invalid floats, just print a message and skip it
                std::cout << "CSVReader::readMarketCSV bad data (invalid float) at line " << lineNum << std::endl;
                continue; // skip this line
            }
        }
    }    

    // print how many entries we successfully read
    std::cout << "CSVReader::readMarketCSV read " << entries.size() << " entries"  << std::endl;
    return entries; 
}


// split a line into tokens based on separator, e.g. ','
// starter code
std::vector<std::string> CSVReader::tokenise(const std::string& line, char separator)
{
    std::vector<std::string> tokens; // output vector
    signed int start, end;
    std::string token;

    start = line.find_first_not_of(separator, 0); // skip any leading separators
    do{
        end = line.find_first_of(separator, start); // find next separator
        if (start == line.length() || start == end) break; // nothing left to parse
        if (end >= 0) token = line.substr(start, end - start); // extract token
        else token = line.substr(start, line.length() - start); // last token
        tokens.push_back(token); // add to vector
        start = end + 1; // move past the separator
    }while(end > 0);

    return tokens; 
}

// convert a vector of strings into OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(const std::vector<std::string>& tokens)
{
    double price, amount;

    if (tokens.size() != 5) // not enough or too many tokens
    {
        std::cout << "Bad line " << std::endl;
        throw std::exception{};
    }

    // parse price and amount, might throw
    try {
        price = std::stod(tokens[3]);
        amount = std::stod(tokens[4]);
    }catch(const std::exception& e){
        std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[3]<< std::endl;
        std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[4]<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       tokens[0], // timestamp
                       tokens[1], // product
                       OrderBookEntry::stringToOrderBookType(tokens[2])}; // order type

    return obe; 
}

// convert individual strings to OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType)
{
    double price, amount;

    try {
        price = std::stod(priceString); // convert price to double
        amount = std::stod(amountString); // convert amount to double
    }catch(const std::exception& e){
        std::cout << "CSVReader::stringsToOBE Bad float! " << priceString<< std::endl;
        std::cout << "CSVReader::stringsToOBE Bad float! " << amountString<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       timestamp,
                       product, 
                       orderType};
                
    return obe;
}

// write any csv data to a file, append or overwrite
// personal implementation
void CSVReader::writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append)
{
    // open the file in append or truncate mode
    std::ofstream file(filename, append ? std::ios::app : std::ios::trunc);
    if (!file.is_open()) {
        std::cerr << "Failed to open CSV file: " << filename << std::endl;
        return; // can't continue
    }

    // write each row
    for (const auto& row : data) {
        for (size_t i = 0; i < row.size(); ++i) {
            file << row[i]; // write the cell
            if (i < row.size() - 1) file << ","; // add comma between columns
        }
        file << "\n"; // end of row
    }
}

==============================
FILE: CSVReader.h
==============================
#pragma once
#include "../market/OrderBookEntry.h"
#include <vector>
#include <string>

class CSVReader {
public:
    // constructor, nothing special here
    CSVReader() {}  // trivial constructor

    // read the market csv into a vector of OrderBookEntry objects
    // starter code
    static std::vector<OrderBookEntry> readMarketCSV(const std::string& filename);

    // split a line into tokens based on separator, e.g. ','
    // starter code
    static std::vector<std::string> tokenise(const std::string& line, char separator);

    // convert a vector of strings into an OrderBookEntry
    // starter code
    static OrderBookEntry stringsToOBE(const std::vector<std::string>& tokens);

    // convert individual strings into an OrderBookEntry
    // starter code
    OrderBookEntry stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType);

    // write any csv data to a file
    // personal implementation
    static void writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append = true);
};

==============================
FILE: DateUtils.cpp
==============================
#include "DateUtils.h"
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm> 

// convert "YYYY-MM-DD" or "YYYY/MM/DD HH:MM:SS(.micro)" string to tm struct
// personal implementation
std::tm DateUtils::stringToTm(const std::string& dateStr)
{
    std::tm timeStruct = {};
    std::string cleanedStr = dateStr;

    // strip fractional seconds if present (after dot)
    auto dotPos = cleanedStr.find('.');
    if (dotPos != std::string::npos) {
        cleanedStr = cleanedStr.substr(0, dotPos); // remove microseconds
    }

    // replace '/' with '-' to handle both formats
    std::replace(cleanedStr.begin(), cleanedStr.end(), '/', '-');

    // parse using standard YYYY-MM-DD HH:MM:SS format
    std::istringstream ss(cleanedStr);
    ss >> std::get_time(&timeStruct, "%Y-%m-%d %H:%M:%S");
    if (ss.fail()) {
        // parsing failed: maybe only date without time
        ss.clear();
        ss.str(cleanedStr);
        ss >> std::get_time(&timeStruct, "%Y-%m-%d");
        if (ss.fail()) {
            std::cerr << "DateUtils::stringToTm failed to parse: " << dateStr << std::endl;
        }
    }

    // tm_mon is 0-indexed, tm_mday is fine
    return timeStruct;
}

// convert tm struct back to "YYYY-MM-DD HH:MM:SS"
std::string DateUtils::tmToString(const std::tm& timeStruct)
{
    std::ostringstream ss;
    ss << std::put_time(&timeStruct, "%Y-%m-%d %H:%M:%S"); // simple formatting
    return ss.str();
}

// get year from tm
int DateUtils::getYear(const std::tm& timeStruct)
{
    return timeStruct.tm_year + 1900; // tm_year = years since 1900
}

// get month from tm
int DateUtils::getMonth(const std::tm& timeStruct)
{
    return timeStruct.tm_mon + 1; // tm_mon = 0..11
}

// get day from tm
int DateUtils::getDay(const std::tm& timeStruct)
{
    return timeStruct.tm_mday; // tm_mday = 1..31
}

// returns true if date1 <= date2
bool DateUtils::isBeforeOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) < getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) < getMonth(date2);
    return getDay(date1) <= getDay(date2);
}

// returns true if date1 >= date2
bool DateUtils::isAfterOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) > getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) > getMonth(date2);
    return getDay(date1) >= getDay(date2);
}

==============================
FILE: DateUtils.h
==============================
#pragma once
#include <string>
#include <ctime>

// personal implementation
// utility functions for date parsing, extraction, and comparison
class DateUtils {
public:
    DateUtils() {}

    // convert a timestamp string "YYYY-MM-DD" → tm struct
    static std::tm stringToTm(const std::string& dateStr);

    // convert a tm struct back to string "YYYY-MM-DD"
    static std::string tmToString(const std::tm& timeStruct);

    // extract year from tm
    static int getYear(const std::tm& timeStruct);

    // extract month from tm
    static int getMonth(const std::tm& timeStruct);

    // extract day from tm
    static int getDay(const std::tm& timeStruct);

    // compare two dates, returns true if date1 <= date2
    static bool isBeforeOrEqual(const std::tm& date1, const std::tm& date2);

    // compare two dates, returns true if date1 >= date2
    static bool isAfterOrEqual(const std::tm& date1, const std::tm& date2);
};

==============================
FILE: main.cpp
==============================
#include <iostream>
#include <string>
#include "wallet/WalletManager.h"
#include "wallet/Wallet.h"
#include "wallet/Transaction.h"

int main() {
    // fake CSV files for testing
    std::string walletsCSV = "data/test_wallets.csv";
    std::string transactionsCSV = "data/test_transactions.csv";

    // create WalletManager
    WalletManager wm(walletsCSV, transactionsCSV);

    // test user
    std::string userId = "1234567890";

    // load wallet (should be empty at first)
    Wallet wallet = wm.loadWallet(userId);
    std::cout << "initial wallet:\n" << wallet << std::endl;

    // deposit funds
    std::cout << "depositing 1000 USDT...\n";
    wm.deposit(userId, wallet, 1000);
    std::cout << "wallet after deposit:\n" << wallet << std::endl;

    // withdraw some funds
    std::cout << "withdrawing 250 USDT...\n";
    wm.withdraw(userId, wallet, 250);
    std::cout << "wallet after withdrawal:\n" << wallet << std::endl;

    // simulate ask transaction (personal implementation)
    Transaction askTx(userId, TransactionType::ASK, "BTC/USDT", 0.5, wallet.containsCurrency("USDT",0) ?  wallet.containsCurrency("USDT",0) : 0, "2026-01-04 16:00:00");
    wm.deposit(userId, wallet, 0); // just to trigger logging example
    wm.deposit(userId, wallet, 0); // dummy deposits to log ask/bid

    // simulate bid transaction (personal implementation)
    Transaction bidTx(userId, TransactionType::BID, "ETH/USDT", 2, wallet.containsCurrency("USDT",0) ?  wallet.containsCurrency("USDT",0) : 0, "2026-01-04 16:05:00");
    wm.deposit(userId, wallet, 0); // dummy

    // print recent transactions
    std::cout << "\nrecent transactions:\n";
    auto recent = wm.getRecentTransactions(userId, 5);
    for (auto& tx : recent) {
        std::cout << tx.userId << " | " 
                  << Transaction::typeToString(tx.type) << " | "
                  << tx.product << " | "
                  << tx.amount << " | "
                  << tx.balanceAfter << " | "
                  << tx.timestamp;
        std::cout << "\n";
    }

    // print summary statistics
    std::cout << "\nstatistics for user " << userId << ":\n";
    wm.printStatistics(userId);

    return 0;
}
==============================
FILE: Candlestick.cpp
==============================
#include "Candlestick.h"
#include <algorithm>

Candlestick::Candlestick(std::string date,
                         double open,
                         double high,
                         double low,
                         double close)
    : date(date),
      open(open),
      high(high),
      low(low),
      close(close)
{
    // nothing else to do here
}

// personal implementation
// prices are assumed to be ordered from earliest → latest
Candlestick Candlestick::compute(const std::string& date,
                                 const std::vector<double>& prices)
{
    // open is the first trade price in this period
    double open = prices.front();

    // close is the last trade price in this period
    double close = prices.back();

    // highest traded price in this period
    double high = *std::max_element(prices.begin(), prices.end());

    // lowest traded price in this period
    double low = *std::min_element(prices.begin(), prices.end());

    // return a fully constructed candlestick object
    return Candlestick(date, open, high, low, close);
}

==============================
FILE: Candlestick.h
==============================
#pragma once
#include <string>
#include <vector>

// represents one OHLC summary for a single time bucket (day / month / year)
// used in task 1 for candlestick computation
class Candlestick
{
public:
    // date string depends on timeframe:
    // YYYY (yearly), YYYY-MM (monthly), YYYY-MM-DD (daily)
    std::string date;

    // open: first price in the time bucket
    // high: max price in the time bucket
    // low: min price in the time bucket
    // close: last price in the time bucket
    double open;
    double high;
    double low;
    double close;

    // simple constructor, just assigns values
    Candlestick(std::string date,
                double open,
                double high,
                double low,
                double close);

    // personal implementation
    // computes OHLC values from a list of prices already in chronological order
    static Candlestick compute(const std::string& date,
                               const std::vector<double>& prices);
};

==============================
FILE: MarketDataLoader.cpp
==============================
#include "MarketDataLoader.h"
#include "../core/CSVReader.h"
#include "../core/DateUtils.h"

// reuses the provided CSVReader to load market data
MarketDataLoader::MarketDataLoader(const std::string& marketCSV)
{
    // market csv is read once and cached in memory
    orders = CSVReader::readMarketCSV(marketCSV);
}

std::vector<Candlestick> MarketDataLoader::computeCandlesticks(
    const std::string& product,
    OrderBookType type,
    Timeframe timeframe)
{
    // map used to group prices by date bucket
    // key   → date string (e.g. 2023-06-01)
    // value → list of prices in chronological order
    std::map<std::string, std::vector<double>> buckets;

    // filter orders by product and order type
    for (const OrderBookEntry& e : orders)
    {
        if (e.product == product && e.orderType == type)
        {
            // determine which bucket this order belongs to
            std::string bucket = getTimeBucket(e.timestamp, timeframe);

            // add price to the corresponding bucket
            buckets[bucket].push_back(e.price);
        }
    }

    std::vector<Candlestick> result;

    // compute OHLC values for each bucket
    for (const auto& pair : buckets)
    {
        result.push_back(
            Candlestick::compute(pair.first, pair.second)
        );
    }

    return result;
}

// personal implementation
// converts a timestamp string into a date bucket string
std::string MarketDataLoader::getTimeBucket(const std::string& timestamp,
                                            Timeframe timeframe)
{
    // parse timestamp into tm struct using shared utility
    std::tm time = DateUtils::stringToTm(timestamp);

    int year  = DateUtils::getYear(time);  // extract year
    int month = DateUtils::getMonth(time); // extract month
    int day   = DateUtils::getDay(time);   // extract day
    int hour  = time.tm_hour;              // extract hour
    int min   = time.tm_min;               // extract minute
    int sec   = time.tm_sec;               // extract second

    // helper for two-digit formatting
    auto twoDigits = [](int x){ return (x < 10 ? "0" : "") + std::to_string(x); };

    if (timeframe == Timeframe::Yearly)
    {
        // yearly bucket: YYYY
        return std::to_string(year);
    }

    if (timeframe == Timeframe::Monthly)
    {
        // monthly bucket: YYYY-MM
        return std::to_string(year) + "-" + twoDigits(month);
    }

    if (timeframe == Timeframe::Daily)
    {
        // daily bucket: YYYY-MM-DD
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day);
    }

    if (timeframe == Timeframe::Hourly)
    {
        // hourly bucket: YYYY-MM-DD HH
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour);
    }

    if (timeframe == Timeframe::Minutely)
    {
        // minutely bucket: YYYY-MM-DD HH:MM
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour) + ":" + twoDigits(min);
    }

    if (timeframe == Timeframe::Secondly)
    {
        // secondly bucket: YYYY-MM-DD HH:MM:SS
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour) + ":" + twoDigits(min) + ":" + twoDigits(sec);
    }

    // fallback in case of unknown timeframe
    return timestamp;
}


==============================
FILE: MarketDataLoader.h
==============================
#pragma once
#include <vector>
#include <string>
#include <map>

#include "OrderBookEntry.h"
#include "Candlestick.h"

// time grouping options for task 1
enum class Timeframe {
    Daily,
    Monthly,
    Yearly,
    Hourly,    
    Minutely,  
    Secondly  
};

// personal implementation
// handles loading market data and computing candlestick summaries
class MarketDataLoader
{
public:
    // loads all market orders from the given csv file
    MarketDataLoader(const std::string& marketCSV);

    // filters by product and order type (ask / bid),
    // groups by timeframe, then computes candlesticks
    std::vector<Candlestick> computeCandlesticks(
        const std::string& product,
        OrderBookType type,
        Timeframe timeframe
    );

private:
    // holds all market orders loaded from the dataset
    std::vector<OrderBookEntry> orders;

    // converts a timestamp into the correct bucket string
    // depending on daily / monthly / yearly mode
    std::string getTimeBucket(const std::string& timestamp,
                              Timeframe timeframe);
};

==============================
FILE: OrderBookEntry.cpp
==============================
#include "OrderBookEntry.h"

// starter code – initializes a market order entry
OrderBookEntry::OrderBookEntry(double _price,
                               double _amount,
                               std::string _timestamp,
                               std::string _product,
                               OrderBookType _orderType,
                               std::string _username)
    : price(_price),
      amount(_amount),
      timestamp(_timestamp),
      product(_product),
      orderType(_orderType),
      username(_username)
{
    // nothing else to do here
}

// starter code – convert string from CSV → enum type
OrderBookType OrderBookEntry::stringToOrderBookType(std::string s) {
    if (s == "ask") {
        return OrderBookType::ask;
    }
    if (s == "bid") {
        return OrderBookType::bid;
    }
    // fallback for unknown/unsupported types
    return OrderBookType::unknown;
}

==============================
FILE: OrderBookEntry.h
==============================
#pragma once
#include <string>

// starter code – represents one market order
enum class OrderBookType { bid, ask, unknown, asksale, bidsale };

class OrderBookEntry {
public:
    // constructor – creates a trade/order object
    OrderBookEntry(double _price,
                   double _amount,
                   std::string _timestamp,
                   std::string _product,
                   OrderBookType _orderType,
                   std::string username = "dataset");

    // helper: convert string to enum
    static OrderBookType stringToOrderBookType(std::string s);

    // sorting helpers
    static bool compareByTimestamp(OrderBookEntry& e1, OrderBookEntry& e2) {
        // orders sorted earliest → latest
        return e1.timestamp < e2.timestamp;
    }

    static bool compareByPriceAsc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // low → high price
        return e1.price < e2.price;
    }

    static bool compareByPriceDesc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // high → low price
        return e1.price > e2.price;
    }

    // core order properties
    double price;            // order price
    double amount;           // order amount
    std::string timestamp;   // string timestamp e.g. "2020-03-17 12:00:00"
    std::string product;     // product pair e.g. "ETH/USDT"
    OrderBookType orderType; // bid / ask / etc.
    std::string username;    // source of the order
};

==============================
FILE: User.cpp
==============================
#include "User.h"
#include <vector>

// personal implementation

// constructor just assigns all fields
User::User(const std::string& fullName,
           const std::string& email,
           const std::string& hashedPassword,
           const std::string& userID,
           const std::string& walletID)
    : fullName(fullName),
      email(email),
      hashedPassword(hashedPassword),
      userID(userID),
      walletID(walletID)
{
}

// simple getters
std::string User::getUserID() const { return userID; }
std::string User::getFullName() const { return fullName; }
std::string User::getEmail() const { return email; }
std::string User::getHashedPassword() const { return hashedPassword; }
std::string User::getWalletID() const { return walletID; }

// convert user fields to csv row
std::vector<std::string> User::toCSVRow() const {
    return {userID, fullName, email, hashedPassword, walletID};
}

==============================
FILE: User.h
==============================
#pragma once
#include <string>
#include <vector>

// full file is personal implementation
class User {
public:
    User() = default;

    // constructor for creating a new user object
    User(const std::string& fullName,
         const std::string& email,
         const std::string& hashedPassword,
         const std::string& userID,
         const std::string& walletID);

    // getters
    std::string getUserID() const;         // return unique 10-digit ID
    std::string getFullName() const;       // return full name
    std::string getEmail() const;          // return email
    std::string getHashedPassword() const; // return hashed password
    std::string getWalletID() const;       // return linked wallet ID

    // convert user to csv row for saving
    std::vector<std::string> toCSVRow() const;

private:
    std::string userID;        // unique 10-digit ID
    std::string fullName;      // user's full name
    std::string email;         // user's email
    std::string hashedPassword; // hashed password using std::hash<string>
    std::string walletID;      // link to wallet CSV
};

==============================
FILE: UserManager.cpp
==============================
#include "UserManager.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <random>
#include <functional> // std::hash

// personal implementation

// constructor just loads all users from csv
UserManager::UserManager(const std::string& userCSV)
    : userCSVFile(userCSV)
{
    loadUsers();
}

// load users from csv into vector
void UserManager::loadUsers() {
    std::ifstream file(userCSVFile);
    if (!file.is_open()) return; // nothing to load

    std::string line;
    while (std::getline(file, line)) {
        std::vector<std::string> tokens = CSVReader::tokenise(line, ',');
        if (tokens.size() != 5) continue; // skip malformed line

        // create user object and store in vector
        User user(tokens[1], tokens[2], tokens[3], tokens[0], tokens[4]);
        users.push_back(user);
    }
}

// append a single user to csv
void UserManager::saveUser(const User& user) {
    CSVReader::writeCSV(userCSVFile, {user.toCSVRow()}, true);
}

// check if user already exists by full name + email
bool UserManager::userExists(const std::string& fullName, const std::string& email) const {
    for (const auto& u : users) {
        if (u.getFullName() == fullName && u.getEmail() == email) return true;
    }
    return false;
}

// generate unique 10-digit ID for user
std::string UserManager::generateUniqueUserID() const {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 9);

    std::string id;
    bool unique = false;
    while (!unique) {
        id.clear();
        for (int i = 0; i < 10; ++i) id += std::to_string(dis(gen));

        // make sure id isn't already taken
        unique = true;
        for (const auto& u : users) {
            if (u.getUserID() == id) {
                unique = false;
                break;
            }
        }
    }
    return id;
}

// deterministic hash using std::hash with fixed seed
std::string UserManager::hashPassword(const std::string& password) const {
    // std::hash itself is called deterministically here
    std::hash<std::string> hasher;
    size_t rawHash = hasher(password);

    // convert to string using hex, ensures same result across platforms/runs
    std::stringstream ss;
    ss << std::hex << rawHash; 
    return ss.str();
}

// register a new user
bool UserManager::registerUser(const std::string& fullName,
                               const std::string& email,
                               const std::string& password,
                               User& outUser)
{
    if (userExists(fullName, email)) {
        std::cout << "User with this name and email already exists.\n";
        return false;
    }

    // generate id, wallet link, hash password
    std::string userID = generateUniqueUserID();
    std::string walletID = userID + "_wallet";
    std::string hashedPassword = hashPassword(password);

    // create user object, store in memory and csv
    User newUser(fullName, email, hashedPassword, userID, walletID);
    users.push_back(newUser);
    saveUser(newUser);

    outUser = newUser; // return created user
    return true;
}

// login user by id + password
bool UserManager::loginUser(const std::string& userID,
                            const std::string& password,
                            User& outUser)
{
    std::string hashedInput = hashPassword(password);
    for (const auto& u : users) {
        if (u.getUserID() == userID && u.getHashedPassword() == hashedInput) {
            outUser = u;
            return true;
        }
    }
    return false;
}

// return all users in memory
std::vector<User> UserManager::getAllUsers() const {
    return users;
}

==============================
FILE: UserManager.h
==============================
#pragma once
#include "User.h"
#include "../core/CSVReader.h"
#include <string>
#include <vector>
#include <unordered_map>

// personal implementation
class UserManager {
public:
    UserManager(const std::string& userCSV); // load users from CSV on init

    // register a new user, returns false if duplicate
    bool registerUser(const std::string& fullName,
                      const std::string& email,
                      const std::string& password,
                      User& outUser);

    // login existing user by ID + password
    bool loginUser(const std::string& userID,
                   const std::string& password,
                   User& outUser);

    // return all loaded users
    std::vector<User> getAllUsers() const;

private:
    std::string userCSVFile;     // csv file storing users
    std::vector<User> users;     // in-memory cache

    // helpers
    void loadUsers();                               // load from csv
    void saveUser(const User& user);               // append user to csv
    bool userExists(const std::string& fullName, const std::string& email) const; // check duplicates
    std::string generateUniqueUserID() const;      // generate unique 10-digit ID
    std::string hashPassword(const std::string& password) const; // hash password
};

==============================
FILE: Transaction.cpp
==============================
#include "Transaction.h"
#include <stdexcept> // for std::runtime_error


// personal implementation

// simple constructor, just assign everything
Transaction::Transaction(std::string userId,
                         TransactionType type,
                         std::string product,
                         double amount,
                         double balanceAfter,
                         std::string timestamp)
    : userId(userId),
      type(type),
      product(product),
      amount(amount),
      balanceAfter(balanceAfter),
      timestamp(timestamp)
{}

// convert transaction to a vector of strings for csv
std::vector<std::string> Transaction::toCSVRow() const
{
    return {
        userId,
        typeToString(type),       // convert enum to string
        product,
        std::to_string(amount),   // store amount
        std::to_string(balanceAfter),
        timestamp
    };
}

// rebuild a transaction from a csv row
Transaction Transaction::fromCSVRow(const std::vector<std::string>& row)
{
    return Transaction(
        row[0],                       // user id
        stringToType(row[1]),         // type
        row[2],                       // product
        std::stod(row[3]),            // amount
        std::stod(row[4]),            // balance after
        row[5]                        // timestamp
    );
}

// convert enum to string
std::string Transaction::typeToString(TransactionType type)
{
    switch (type)
    {
        case TransactionType::DEPOSIT:  return "DEPOSIT";
        case TransactionType::WITHDRAW: return "WITHDRAW";
        case TransactionType::ASK:      return "ASK";
        case TransactionType::BID:      return "BID";
    }
    return ""; // fallback
}

// convert string back to enum
TransactionType Transaction::stringToType(const std::string& str)
{
    if (str == "DEPOSIT")  return TransactionType::DEPOSIT;
    if (str == "WITHDRAW") return TransactionType::WITHDRAW;
    if (str == "ASK")      return TransactionType::ASK;
    if (str == "BID")      return TransactionType::BID;
    throw std::runtime_error("Invalid transaction type");
}

==============================
FILE: Transaction.h
==============================
#pragma once
#include <string>
#include <vector>

// personal implementation

// type of transaction
enum class TransactionType
{
    DEPOSIT,
    WITHDRAW,
    ASK,
    BID
};

// stores a single transaction
class Transaction
{
public:
    std::string userId;      // who did it
    TransactionType type;    // type of tx
    std::string product;     // currency or product
    double amount;           // how much involved
    double balanceAfter;     // wallet balance after tx
    std::string timestamp;   // when it happened

    // constructor
    Transaction(std::string userId,
                TransactionType type,
                std::string product,
                double amount,
                double balanceAfter,
                std::string timestamp);

    // convert to csv row (for saving)
    std::vector<std::string> toCSVRow() const;

    // rebuild transaction from csv row
    static Transaction fromCSVRow(const std::vector<std::string>& row);

    // helpers to convert type enum <-> string
    static std::string typeToString(TransactionType type);
    static TransactionType stringToType(const std::string& str);
};

==============================
FILE: Wallet.cpp
==============================
#include "Wallet.h"
#include <iostream>
#include "CSVReader.h"

Wallet::Wallet()
{


}

void Wallet::insertCurrency(std::string type, double amount)
{
    double balance;
    if (amount < 0)
    {
        throw std::exception{};
    }
    if (currencies.count(type) == 0) // not there yet
    {
        balance = 0;
    }
    else { // is there 
        balance = currencies[type];
    }
    balance += amount; 
    currencies[type] = balance; 
}

bool Wallet::removeCurrency(std::string type, double amount)
{
    if (amount < 0)
    {
        return false; 
    }
    if (currencies.count(type) == 0) // not there yet
    {
        //std::cout << "No currency for " << type << std::endl;
        return false;
    }
    else { // is there - do  we have enough
        if (containsCurrency(type, amount))// we have enough
        {
            //std::cout << "Removing " << type << ": " << amount << std::endl;
            currencies[type] -= amount;
            return true;
        } 
        else // they have it but not enough.
            return false; 
    }
}

bool Wallet::containsCurrency(std::string type, double amount)
{
    if (currencies.count(type) == 0) // not there yet
        return false;
    else 
        return currencies[type] >= amount;
    
}

double Wallet::getBalance(const std::string& type) const
{
    auto it = currencies.find(type);
    if (it != currencies.end()) return it->second; // return actual amount
    return 0.0;
}

std::string Wallet::toString()
{
    std::string s;
    for (std::pair<std::string,double> pair : currencies)
    {
        std::string currency = pair.first;
        double amount = pair.second;
        s += currency + " : " + std::to_string(amount) + "\n";
    }
    return s;
}

bool Wallet::canFulfillOrder(OrderBookEntry order)
{
    std::vector<std::string> currs = CSVReader::tokenise(order.product, '/');
    // ask
    if (order.orderType == OrderBookType::ask)
    {
        double amount = order.amount;
        std::string currency = currs[0];
        std::cout << "Wallet::canFulfillOrder " << currency << " : " << amount << std::endl;

        return containsCurrency(currency, amount);
    }
    // bid
    if (order.orderType == OrderBookType::bid)
    {
        double amount = order.amount * order.price;
        std::string currency = currs[1];
        std::cout << "Wallet::canFulfillOrder " << currency << " : " << amount << std::endl;
        return containsCurrency(currency, amount);
    }


    return false; 
}
      

void Wallet::processSale(OrderBookEntry& sale)
{
    std::vector<std::string> currs = CSVReader::tokenise(sale.product, '/');
    // ask
    if (sale.orderType == OrderBookType::asksale)
    {
        double outgoingAmount = sale.amount;
        std::string outgoingCurrency = currs[0];
        double incomingAmount = sale.amount * sale.price;
        std::string incomingCurrency = currs[1];

        currencies[incomingCurrency] += incomingAmount;
        currencies[outgoingCurrency] -= outgoingAmount;

    }
    // bid
    if (sale.orderType == OrderBookType::bidsale)
    {
        double incomingAmount = sale.amount;
        std::string incomingCurrency = currs[0];
        double outgoingAmount = sale.amount * sale.price;
        std::string outgoingCurrency = currs[1];

        currencies[incomingCurrency] += incomingAmount;
        currencies[outgoingCurrency] -= outgoingAmount;
    }
}
std::ostream& operator<<(std::ostream& os,  Wallet& wallet)
{
    os << wallet.toString();
    return os;
}


==============================
FILE: Wallet.h
==============================
#pragma once

#include <string>
#include <map>
#include "../market/OrderBookEntry.h"
#include <iostream>

// reused code
class Wallet 
{
public:
    Wallet();
    void insertCurrency(std::string type, double amount);
    bool removeCurrency(std::string type, double amount);
    bool containsCurrency(std::string type, double amount);
    bool canFulfillOrder(OrderBookEntry order);
    void processSale(OrderBookEntry& sale);
    std::string toString();
    friend std::ostream& operator<<(std::ostream& os, Wallet& wallet);

    // personal implementation: get actual balance
    double getBalance(const std::string& type) const;

private:
    std::map<std::string,double> currencies;
};

==============================
FILE: WalletManager.cpp
==============================
#include "WalletManager.h"
#include <iostream>
#include <ctime>
#include <fstream>   // for ifstream
#include <string>    // for std::string

// personal implementation
// wallet balances are tracked in base currency (USDT)


// just assign filenames
WalletManager::WalletManager(const std::string& walletFile,
                             const std::string& transactionFile)
    : walletsCSV(walletFile),
      transactionsCSV(transactionFile)
{}

// load wallet for user
Wallet WalletManager::loadWallet(const std::string& userId)
{
    Wallet wallet;
    std::ifstream file(walletsCSV);
    std::string line;

    while (std::getline(file, line))
    {
        auto tokens = CSVReader::tokenise(line, ',');
        if (tokens[0] == userId)
        {
            wallet.insertCurrency(tokens[1], std::stod(tokens[2]));
        }
    }
    return wallet;
}

// save wallet
void WalletManager::saveWallet(const std::string& userId, Wallet& wallet)
{
    std::ifstream in(walletsCSV);
    std::vector<std::vector<std::string>> rows;
    std::string line;

    // keep all other users
    while (std::getline(in, line))
    {
        auto tokens = CSVReader::tokenise(line, ',');
        if (tokens[0] != userId)
            rows.push_back(tokens);
    }

    // write updated balance
    rows.push_back({
        userId,
        "USDT",
        std::to_string(wallet.getBalance("USDT"))
    });

    CSVReader::writeCSV(walletsCSV, rows, false); // overwrite
}


// deposit funds into wallet, log tx
bool WalletManager::deposit(const std::string& userId,
                            Wallet& wallet,
                            double amount)
{
    if (amount <= 0) return false; // reject bad amounts

    wallet.insertCurrency("USDT", amount); // add to wallet
    saveWallet(userId, wallet);

    auto now = std::time(nullptr);

    // get actual balance after deposit once
    double balanceAfter = wallet.getBalance("USDT"); 

    Transaction tx(userId, TransactionType::DEPOSIT,
                   "USDT",
                   amount,
                   balanceAfter,
                   std::ctime(&now));

    // append to history
    logTransaction(tx); 
    return true;
}


// withdraw funds from wallet, log tx
bool WalletManager::withdraw(const std::string& userId,
                             Wallet& wallet,
                             double amount)
{
    if (!wallet.removeCurrency("USDT", amount)) return false; // not enough
    saveWallet(userId, wallet);

    auto now = std::time(nullptr);

    double balanceAfter = wallet.getBalance("USDT"); // correct balance

    Transaction tx(userId,
                   TransactionType::WITHDRAW,
                   "USDT",
                   amount,
                   balanceAfter,
                   std::ctime(&now));

    logTransaction(tx);
    return true;
}

// append transaction to csv
void WalletManager::logTransaction(const Transaction& tx)
{
    CSVReader::writeCSV(
        transactionsCSV,
        {tx.toCSVRow()},
        true
    );
}

// load all transactions from file
std::vector<Transaction> WalletManager::loadAllTransactions()
{
    std::ifstream file(transactionsCSV);
    std::vector<Transaction> result;
    std::string line;

    while (std::getline(file, line))
    {
        auto tokens = CSVReader::tokenise(line, ',');
        if (tokens.size() == 6)
            result.push_back(Transaction::fromCSVRow(tokens));
    }
    return result;
}

// get last n transactions for a user
std::vector<Transaction> WalletManager::getRecentTransactions(
    const std::string& userId,
    int count)
{
    auto all = loadAllTransactions();
    std::vector<Transaction> filtered;

    // filter for user
    for (auto& tx : all)
        if (tx.userId == userId)
            filtered.push_back(tx);

    // return last count
    if (filtered.size() <= count) return filtered;

    return std::vector<Transaction>(
        filtered.end() - count,
        filtered.end()
    );
}

// compute some stats for a user
void WalletManager::printStatistics(const std::string& userId,
                                    const std::string& productFilter)
{
    auto all = loadAllTransactions();

    int asks = 0, bids = 0;
    double totalSpent = 0.0;

    for (const auto& tx : all)
    {
        if (tx.userId != userId) continue;            // skip others
        if (!productFilter.empty() && tx.product != productFilter) continue; // filter

        if (tx.type == TransactionType::ASK) asks++;
        if (tx.type == TransactionType::BID) bids++;

        // only count outgoing money (withdrawals, asks, bids), not deposits
        if (tx.type == TransactionType::WITHDRAW || tx.type == TransactionType::ASK || tx.type == TransactionType::BID)
            totalSpent += tx.amount;
    }

    // print stats
    std::cout << "ASKS: " << asks << "\n";
    std::cout << "BIDS: " << bids << "\n";
    std::cout << "TOTAL SPENT: " << totalSpent << "\n";
}
==============================
FILE: WalletManager.h
==============================
#pragma once
#include "Wallet.h"
#include "Transaction.h"
#include "../core/CSVReader.h"
#include "../core/DateUtils.h"
#include <vector>

// personal implementation: manages wallets + transaction history
class WalletManager
{
public:
    WalletManager(const std::string& walletFile,
                  const std::string& transactionFile);

    // load a wallet from csv
    Wallet loadWallet(const std::string& userId);

    // save current wallet state
    void saveWallet(const std::string& userId, Wallet& wallet);

    // deposit and log
    bool deposit(const std::string& userId, Wallet& wallet, double amount);

    // withdraw and log
    bool withdraw(const std::string& userId, Wallet& wallet, double amount);

    // get last n transactions
    std::vector<Transaction> getRecentTransactions(
        const std::string& userId,
        int count = 5
    );

    // compute simple stats for a user
    void printStatistics(const std::string& userId,
                         const std::string& productFilter = "");

private:
    std::string walletsCSV;        // where wallets are saved
    std::string transactionsCSV;   // transaction log

    // helper: append transaction to csv
    void logTransaction(const Transaction& tx);

    // load all transactions
    std::vector<Transaction> loadAllTransactions();
};
