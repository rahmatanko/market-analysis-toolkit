
==============================
FILE: CSVReader.cpp
==============================
#include "CSVReader.h"
#include <iostream>
#include <fstream>
#include <sstream>

// read the market CSV file and convert each line to OrderBookEntry
// starter code
std::vector<OrderBookEntry> CSVReader::readMarketCSV(const std::string& filename)
{
    std::vector<OrderBookEntry> entries; // this will hold all the entries from the CSV

    std::ifstream csvFile{filename}; // open the file
    std::string line;
    int lineNum = 0; // keep track of the line number
    if (csvFile.is_open())
    {
        while(std::getline(csvFile, line)) // read line by line
        {
            ++lineNum;
            std::vector<std::string> tokens = tokenise(line, ',');
            
            // skip malformed lines
            if (tokens.size() != 5) {
                // std::cout << "CSVReader::readMarketCSV bad data (wrong token count) at line " << lineNum << std::endl;
                continue; // skip this line
            }

            try {
                // convert line to tokens, then tokens to OrderBookEntry
                OrderBookEntry obe = stringsToOBE(tokens);
                entries.push_back(obe); // add to our vector
            } catch(const std::exception& e)
            {
                // if the line has invalid floats, just print a message and skip it
                // std::cout << "CSVReader::readMarketCSV bad data (invalid float) at line " << lineNum << std::endl;
                continue; // skip this line
            }
        }
    }    

    // print how many entries we successfully read
    // std::cout << "CSVReader::readMarketCSV read " << entries.size() << " entries"  << std::endl;
    return entries; 
}


// split a line into tokens based on separator, e.g. ','
// starter code
std::vector<std::string> CSVReader::tokenise(const std::string& line, char separator)
{
    std::vector<std::string> tokens; // output vector
    signed int start, end;
    std::string token;

    start = line.find_first_not_of(separator, 0); // skip any leading separators
    do{
        end = line.find_first_of(separator, start); // find next separator
        if (start == line.length() || start == end) break; // nothing left to parse
        if (end >= 0) token = line.substr(start, end - start); // extract token
        else token = line.substr(start, line.length() - start); // last token
        tokens.push_back(token); // add to vector
        start = end + 1; // move past the separator
    }while(end > 0);

    return tokens; 
}

// convert a vector of strings into OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(const std::vector<std::string>& tokens)
{
    double price, amount;

    if (tokens.size() != 5) // not enough or too many tokens
    {
        std::cout << "Bad line " << std::endl;
        throw std::exception{};
    }

    // parse price and amount, might throw
    try {
        price = std::stod(tokens[3]);
        amount = std::stod(tokens[4]);
    }catch(const std::exception& e){
        // std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[3]<< std::endl;
        // std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[4]<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       tokens[0], // timestamp
                       tokens[1], // product
                       OrderBookEntry::stringToOrderBookType(tokens[2])}; // order type

    return obe; 
}

// convert individual strings to OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType)
{
    double price, amount;

    try {
        price = std::stod(priceString); // convert price to double
        amount = std::stod(amountString); // convert amount to double
    }catch(const std::exception& e){
        // std::cout << "CSVReader::stringsToOBE Bad float! " << priceString<< std::endl;
        // std::cout << "CSVReader::stringsToOBE Bad float! " << amountString<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       timestamp,
                       product, 
                       orderType};
                
    return obe;
}

// write any csv data to a file, append or overwrite
// personal implementation
void CSVReader::writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append)
{
    // open the file in append or truncate mode
    std::ofstream file(filename, append ? std::ios::app : std::ios::trunc);
    if (!file.is_open()) {
        std::cerr << "Failed to open CSV file: " << filename << std::endl;
        return; // can't continue
    }

    // write each row
    for (const auto& row : data) {
        for (size_t i = 0; i < row.size(); ++i) {
            file << row[i]; // write the cell
            if (i < row.size() - 1) file << ","; // add comma between columns
        }
        file << "\n"; // end of row
    }
}

==============================
FILE: CSVReader.h
==============================
#pragma once
#include "../market/OrderBookEntry.h"
#include <vector>
#include <string>

class CSVReader {
public:
    // constructor, nothing special here
    CSVReader() {}  // trivial constructor

    // read the market csv into a vector of OrderBookEntry objects
    // starter code
    static std::vector<OrderBookEntry> readMarketCSV(const std::string& filename);

    // split a line into tokens based on separator, e.g. ','
    // starter code
    static std::vector<std::string> tokenise(const std::string& line, char separator);

    // convert a vector of strings into an OrderBookEntry
    // starter code
    static OrderBookEntry stringsToOBE(const std::vector<std::string>& tokens);

    // convert individual strings into an OrderBookEntry
    // starter code
    OrderBookEntry stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType);

    // write any csv data to a file
    // personal implementation
    static void writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append = true);
};

==============================
FILE: DateUtils.cpp
==============================
#include "DateUtils.h"
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm> 

// convert "YYYY-MM-DD" or "YYYY/MM/DD HH:MM:SS(.micro)" string to tm struct
// personal implementation
std::tm DateUtils::stringToTm(const std::string& dateStr)
{
    std::tm timeStruct = {};
    std::string cleanedStr = dateStr;

    // strip fractional seconds if present (after dot)
    auto dotPos = cleanedStr.find('.');
    if (dotPos != std::string::npos) {
        cleanedStr = cleanedStr.substr(0, dotPos); // remove microseconds
    }

    // replace '/' with '-' to handle both formats
    std::replace(cleanedStr.begin(), cleanedStr.end(), '/', '-');

    // parse using standard YYYY-MM-DD HH:MM:SS format
    std::istringstream ss(cleanedStr);
    ss >> std::get_time(&timeStruct, "%Y-%m-%d %H:%M:%S");
    if (ss.fail()) {
        // parsing failed: maybe only date without time
        ss.clear();
        ss.str(cleanedStr);
        ss >> std::get_time(&timeStruct, "%Y-%m-%d");
        if (ss.fail()) {
            std::cerr << "DateUtils::stringToTm failed to parse: " << dateStr << std::endl;
        }
    }

    // tm_mon is 0-indexed, tm_mday is fine
    return timeStruct;
}

// convert tm struct back to "YYYY-MM-DD HH:MM:SS"
std::string DateUtils::tmToString(const std::tm& timeStruct)
{
    std::ostringstream ss;
    ss << std::put_time(&timeStruct, "%Y-%m-%d %H:%M:%S"); // simple formatting
    return ss.str();
}

// get year from tm
int DateUtils::getYear(const std::tm& timeStruct)
{
    return timeStruct.tm_year + 1900; // tm_year = years since 1900
}

// get month from tm
int DateUtils::getMonth(const std::tm& timeStruct)
{
    return timeStruct.tm_mon + 1; // tm_mon = 0..11
}

// get day from tm
int DateUtils::getDay(const std::tm& timeStruct)
{
    return timeStruct.tm_mday; // tm_mday = 1..31
}

// returns true if date1 <= date2
bool DateUtils::isBeforeOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) < getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) < getMonth(date2);
    return getDay(date1) <= getDay(date2);
}

// returns true if date1 >= date2
bool DateUtils::isAfterOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) > getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) > getMonth(date2);
    return getDay(date1) >= getDay(date2);
}

==============================
FILE: DateUtils.h
==============================
#pragma once
#include <string>
#include <ctime>

// personal implementation
// utility functions for date parsing, extraction, and comparison
class DateUtils {
public:
    DateUtils() {}

    // convert a timestamp string "YYYY-MM-DD" → tm struct
    static std::tm stringToTm(const std::string& dateStr);

    // convert a tm struct back to string "YYYY-MM-DD"
    static std::string tmToString(const std::tm& timeStruct);

    // extract year from tm
    static int getYear(const std::tm& timeStruct);

    // extract month from tm
    static int getMonth(const std::tm& timeStruct);

    // extract day from tm
    static int getDay(const std::tm& timeStruct);

    // compare two dates, returns true if date1 <= date2
    static bool isBeforeOrEqual(const std::tm& date1, const std::tm& date2);

    // compare two dates, returns true if date1 >= date2
    static bool isAfterOrEqual(const std::tm& date1, const std::tm& date2);
};

==============================
FILE: main.cpp
==============================
#include "ui/Menu.h"
#include "user/UserManager.h"
#include "wallet/WalletManager.h"
#include "market/MarketDataLoader.h"
#include <iostream>

int main() {

    // file paths for CSVs 
    const std::string usersCSV       = "data/users.csv";
    const std::string walletsCSV     = "data/wallets.csv";
    const std::string transactionsCSV = "data/transactions.csv";
    const std::string marketCSV      = "data/big_market.csv";

    // initialize core managers with CSV paths
    UserManager userManager(usersCSV);                          
    WalletManager walletManager(walletsCSV, transactionsCSV);  
    MarketDataLoader marketData(marketCSV);                    

    // create menu with references to managers
    Menu menu(userManager, walletManager, marketData);

    // start main loop
    menu.run();

    return 0; // normally never reached
}

==============================
FILE: Candlestick.cpp
==============================
#include "Candlestick.h"
#include <algorithm>

Candlestick::Candlestick(std::string date,
                         double open,
                         double high,
                         double low,
                         double close)
    : date(date),
      open(open),
      high(high),
      low(low),
      close(close)
{
    // nothing else to do here
}

// personal implementation
// prices are assumed to be ordered from earliest → latest
Candlestick Candlestick::compute(const std::string& date,
                                 const std::vector<double>& prices)
{
    // open is the first trade price in this period
    double open = prices.front();

    // close is the last trade price in this period
    double close = prices.back();

    // highest traded price in this period
    double high = *std::max_element(prices.begin(), prices.end());

    // lowest traded price in this period
    double low = *std::min_element(prices.begin(), prices.end());

    // return a fully constructed candlestick object
    return Candlestick(date, open, high, low, close);
}

==============================
FILE: Candlestick.h
==============================
#pragma once
#include <string>
#include <vector>

// represents one OHLC summary for a single time bucket (day / month / year)
// used in task 1 for candlestick computation
class Candlestick
{
public:
    // date string depends on timeframe:
    // YYYY (yearly), YYYY-MM (monthly), YYYY-MM-DD (daily)
    std::string date;

    // open: first price in the time bucket
    // high: max price in the time bucket
    // low: min price in the time bucket
    // close: last price in the time bucket
    double open;
    double high;
    double low;
    double close;

    // simple constructor, just assigns values
    Candlestick(std::string date,
                double open,
                double high,
                double low,
                double close);

    // personal implementation
    // computes OHLC values from a list of prices already in chronological order
    static Candlestick compute(const std::string& date,
                               const std::vector<double>& prices);
};

==============================
FILE: MarketDataLoader.cpp
==============================
#include "MarketDataLoader.h"
#include "../core/CSVReader.h"
#include "../core/DateUtils.h"

// reuses the provided CSVReader to load market data
MarketDataLoader::MarketDataLoader(const std::string& marketCSV)
{
    // market csv is read once and cached in memory
    orders = CSVReader::readMarketCSV(marketCSV);
}

std::vector<Candlestick> MarketDataLoader::computeCandlesticks(
    const std::string& product,
    OrderBookType type,
    Timeframe timeframe)
{
    // map used to group prices by date bucket
    // key   → date string (e.g. 2023-06-01)
    // value → list of prices in chronological order
    std::map<std::string, std::vector<double>> buckets;

    // filter orders by product and order type
    for (const OrderBookEntry& e : orders)
    {
        if (e.product == product && e.orderType == type)
        {
            // determine which bucket this order belongs to
            std::string bucket = getTimeBucket(e.timestamp, timeframe);

            // add price to the corresponding bucket
            buckets[bucket].push_back(e.price);
        }
    }

    std::vector<Candlestick> result;

    // compute OHLC values for each bucket
    for (const auto& pair : buckets)
    {
        result.push_back(
            Candlestick::compute(pair.first, pair.second)
        );
    }

    return result;
}

// personal implementation
// converts a timestamp string into a date bucket string
std::string MarketDataLoader::getTimeBucket(const std::string& timestamp,
                                            Timeframe timeframe)
{
    // parse timestamp into tm struct using shared utility
    std::tm time = DateUtils::stringToTm(timestamp);

    int year  = DateUtils::getYear(time);  // extract year
    int month = DateUtils::getMonth(time); // extract month
    int day   = DateUtils::getDay(time);   // extract day
    int hour  = time.tm_hour;              // extract hour
    int min   = time.tm_min;               // extract minute
    int sec   = time.tm_sec;               // extract second

    // helper for two-digit formatting
    auto twoDigits = [](int x){ return (x < 10 ? "0" : "") + std::to_string(x); };

    if (timeframe == Timeframe::Yearly)
    {
        // yearly bucket: YYYY
        return std::to_string(year);
    }

    if (timeframe == Timeframe::Monthly)
    {
        // monthly bucket: YYYY-MM
        return std::to_string(year) + "-" + twoDigits(month);
    }

    if (timeframe == Timeframe::Daily)
    {
        // daily bucket: YYYY-MM-DD
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day);
    }

    if (timeframe == Timeframe::Hourly)
    {
        // hourly bucket: YYYY-MM-DD HH
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour);
    }

    if (timeframe == Timeframe::Minutely)
    {
        // minutely bucket: YYYY-MM-DD HH:MM
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour) + ":" + twoDigits(min);
    }

    if (timeframe == Timeframe::Secondly)
    {
        // secondly bucket: YYYY-MM-DD HH:MM:SS
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour) + ":" + twoDigits(min) + ":" + twoDigits(sec);
    }

    // fallback in case of unknown timeframe
    return timestamp;
}


==============================
FILE: MarketDataLoader.h
==============================
#pragma once
#include <vector>
#include <string>
#include <map>
#include <set>

#include "OrderBookEntry.h"
#include "Candlestick.h"

// time grouping options for task 1
enum class Timeframe {
    Daily,
    Monthly,
    Yearly,
    Hourly,    
    Minutely,  
    Secondly  
};

// personal implementation
// handles loading market data and computing candlestick summaries
class MarketDataLoader
{
public:
    // loads all market orders from the given csv file
    MarketDataLoader(const std::string& marketCSV);

    // filters by product and order type (ask / bid),
    // groups by timeframe, then computes candlesticks
    std::vector<Candlestick> computeCandlesticks(
        const std::string& product,
        OrderBookType type,
        Timeframe timeframe
    );

    // returns a list of all unique products in the dataset
    std::vector<std::string> getAllProducts() const
    {
        std::set<std::string> uniqueProducts;
        for (const auto& order : orders)
            uniqueProducts.insert(order.product);
        return std::vector<std::string>(uniqueProducts.begin(), uniqueProducts.end());
    }

private:
    // holds all market orders loaded from the dataset
    std::vector<OrderBookEntry> orders;

    // converts a timestamp into the correct bucket string
    // depending on daily / monthly / yearly mode
    std::string getTimeBucket(const std::string& timestamp,
                              Timeframe timeframe);
};

==============================
FILE: OrderBookEntry.cpp
==============================
#include "OrderBookEntry.h"

// starter code – initializes a market order entry
OrderBookEntry::OrderBookEntry(double _price,
                               double _amount,
                               std::string _timestamp,
                               std::string _product,
                               OrderBookType _orderType,
                               std::string _username)
    : price(_price),
      amount(_amount),
      timestamp(_timestamp),
      product(_product),
      orderType(_orderType),
      username(_username)
{
    // nothing else to do here
}

// starter code – convert string from CSV → enum type
OrderBookType OrderBookEntry::stringToOrderBookType(std::string s) {
    if (s == "ask") {
        return OrderBookType::ask;
    }
    if (s == "bid") {
        return OrderBookType::bid;
    }
    // fallback for unknown/unsupported types
    return OrderBookType::unknown;
}

==============================
FILE: OrderBookEntry.h
==============================
#pragma once
#include <string>

// starter code – represents one market order
enum class OrderBookType { bid, ask, unknown, asksale, bidsale };

class OrderBookEntry {
public:
    // constructor – creates a trade/order object
    OrderBookEntry(double _price,
                   double _amount,
                   std::string _timestamp,
                   std::string _product,
                   OrderBookType _orderType,
                   std::string username = "dataset");

    // helper: convert string to enum
    static OrderBookType stringToOrderBookType(std::string s);

    // sorting helpers
    static bool compareByTimestamp(OrderBookEntry& e1, OrderBookEntry& e2) {
        // orders sorted earliest → latest
        return e1.timestamp < e2.timestamp;
    }

    static bool compareByPriceAsc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // low → high price
        return e1.price < e2.price;
    }

    static bool compareByPriceDesc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // high → low price
        return e1.price > e2.price;
    }

    // core order properties
    double price;            // order price
    double amount;           // order amount
    std::string timestamp;   // string timestamp e.g. "2020-03-17 12:00:00"
    std::string product;     // product pair e.g. "ETH/USDT"
    OrderBookType orderType; // bid / ask / etc.
    std::string username;    // source of the order
};

==============================
FILE: Trade.h
==============================
#pragma once
#include <string>
#include "../market/OrderBookEntry.h"

// personal implementation
// simple wrapper used for simulated user trades in task 4
// we reuse OrderBookEntry directly so the rest of the system
// can treat simulated trades like normal market orders
class Trade
{
public:
    // the underlying order data (price, amount, timestamp, etc.)
    OrderBookEntry order;

    // constructor just stores the given order
    Trade(const OrderBookEntry& order)
        : order(order) {}
};

==============================
FILE: TradeSimulator.cpp
==============================
#include "TradeSimulator.h"
#include <chrono>
#include <iomanip>
#include <sstream>
#include <set>

// personal implementation
// all logic in this file is written for task 4

TradeSimulator::TradeSimulator(MarketDataLoader& marketData,
                               WalletManager& walletManager)
    : marketData(marketData),
      walletManager(walletManager)
{
    // nothing else to initialize
}

// returns current system time as "YYYY-MM-DD HH:MM:SS"
// used to simulate trades occurring in 2025/2026
std::string TradeSimulator::getCurrentTimestamp() const
{
    auto now = std::chrono::system_clock::now();
    std::time_t time = std::chrono::system_clock::to_time_t(now);
    std::tm* tm = std::localtime(&time);

    std::ostringstream oss;
    oss << std::put_time(tm, "%Y-%m-%d %H:%M:%S");
    return oss.str();
}

// generate a price with small random variation around a base price
// this avoids unrealistic jumps while still being random
double TradeSimulator::generatePrice(double basePrice)
{
    static std::mt19937 rng(std::random_device{}());
    std::uniform_real_distribution<double> dist(0.95, 1.05);
    return basePrice * dist(rng);
}

void TradeSimulator::simulateTrades(const User& user) 
{
    std::cout << BOLD << CYAN
              << "\n[ SIMULATION ] Starting trade simulation for user "
              << user.getFullName()
              << RESET << "\n";

    // load the user's wallet from csv
    Wallet wallet = walletManager.loadWallet(user.getUserID());

    std::cout << GRAY << "[SIM] Initial wallet state loaded\n" << RESET;

    // list of known products to simulate trades for
    std::vector<std::string> knownProducts = marketData.getAllProducts();

    for (const std::string& product : knownProducts)
    {
        auto candles = marketData.computeCandlesticks(
            product,
            OrderBookType::ask,
            Timeframe::Yearly
        );

        if (candles.empty())
            continue;

        double basePrice = candles.back().close;
        std::string baseCurrency = product.substr(0, product.find('/'));

        std::cout << BOLD << MAGENTA
                  << "\n[PRODUCT] " << product
                  << " | Reference price: " << basePrice
                  << RESET << "\n";

        for (int i = 0; i < 5; ++i)
        {
            std::string timestamp = getCurrentTimestamp();
            double price = generatePrice(basePrice);

            // bid/buy
            double maxAffordable = wallet.getBalance("USDT") / price;
            double bidAmount = std::min(1.0, maxAffordable);
            if (bidAmount > 0)
            {
                OrderBookEntry bid(
                    price,
                    bidAmount,
                    timestamp,
                    product,
                    OrderBookType::bidsale,
                    user.getUserID()
                );

                std::cout << CYAN
                          << "[SIM-BID] Buy " << bidAmount << " "
                          << baseCurrency << " @ " << price
                          << RESET << "\n";

                if (wallet.canFulfillOrder(bid))
                {
                    wallet.processSale(bid);

                    Transaction tx(
                        user.getUserID(),
                        TransactionType::BID,
                        product,
                        price * bidAmount,
                        wallet.getBalance("USDT"),
                        timestamp
                    );

                    walletManager.logTransaction(tx);

                    std::cout << GREEN
                              << "  ✔ Feasible | USDT → "
                              << wallet.getBalance("USDT")
                              << RESET << "\n";
                }
                else
                {
                    std::cout << RED
                              << "  ✘ Rejected (insufficient USDT)"
                              << RESET << "\n";
                }
            }

            // ask/sell
            double assetBalance = wallet.getBalance(baseCurrency);
            double askAmount = std::min(1.0, assetBalance);
            if (askAmount > 0)
            {
                OrderBookEntry ask(
                    price,
                    askAmount,
                    timestamp,
                    product,
                    OrderBookType::asksale,
                    user.getUserID()
                );

                std::cout << YELLOW
                          << "[SIM-ASK] Sell " << askAmount << " "
                          << baseCurrency << " @ " << price
                          << RESET << "\n";

                if (wallet.canFulfillOrder(ask))
                {
                    wallet.processSale(ask);

                    Transaction tx(
                        user.getUserID(),
                        TransactionType::ASK,
                        product,
                        price * askAmount,
                        wallet.getBalance("USDT"),
                        timestamp
                    );

                    walletManager.logTransaction(tx);

                    std::cout << GREEN
                              << "  ✔ Feasible | USDT → "
                              << wallet.getBalance("USDT")
                              << RESET << "\n";
                }
                else
                {
                    std::cout << RED
                              << "  ✘ Rejected (insufficient asset)"
                              << RESET << "\n";
                }
            }
        }
    }

    // cleanup tiny dust
    for (auto& [currency, amount] : wallet.getAllBalances())
    {
        if (amount < 1e-6)
            wallet.removeCurrency(currency, amount);
    }

    walletManager.saveWallet(user.getUserID(), wallet);

    std::cout << BOLD << CYAN
              << "\n[ SIMULATION COMPLETE ]"
              << RESET << "\n"
              << GRAY
              << "• Trades evaluated using historical prices\n"
              << "• Transactions logged\n"
              << "• Wallet state finalized\n"
              << RESET;
}




==============================
FILE: TradeSimulator.h
==============================
#pragma once
#include <vector>
#include <string>
#include <random>

#include "../market/MarketDataLoader.h"
#include "../wallet/WalletManager.h"
#include "../user/User.h"

// ANSI colors
#define RESET   "\033[0m"
#define BOLD    "\033[1m"
#define CYAN    "\033[36m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define RED     "\033[31m"
#define MAGENTA "\033[35m"
#define GRAY    "\033[90m"


// personal implementation
// responsible for simulating user trading activity (task 4)
// generates ask and bid orders and updates wallet state accordingly
class TradeSimulator
{
public:
    // constructor receives shared market data and wallet manager
    // no ownership here, just references
    TradeSimulator(MarketDataLoader& marketData,
                   WalletManager& walletManager);

    // simulate trades for all products for a given logged-in user
    void simulateTrades(const User& user);

private:
    // access to market prices (read-only)
    MarketDataLoader& marketData;

    // handles wallet updates and csv persistence
    WalletManager& walletManager;

    // helper: get current system timestamp as string
    std::string getCurrentTimestamp() const;

    // helper: generate a realistic price based on historical price
    double generatePrice(double basePrice);
};

==============================
FILE: Menu.cpp
==============================
#include "Menu.h"
#include <iostream>
#include <limits>

// personal implementation

// colors for terminal
#define BLUE "\033[1;34m"
#define GREEN "\033[1;32m"
#define RED "\033[1;31m"
#define YELLOW "\033[1;33m"
#define RESET "\033[0m"

// constructor stores references
Menu::Menu(UserManager &userMgr,
           WalletManager &walletMgr,
           MarketDataLoader &market)
    : userManager(userMgr),
      walletManager(walletMgr),
      marketData(market)
{
}

// main loop
void Menu::run()
{
    while (true)
    {
        if (!loggedIn)
            showWelcomeMenu(); // ask user to login/register
        else
            showMainMenu(); // main functionality menu
    }
}

// welcome menu
void Menu::showWelcomeMenu()
{
    std::cout << BLUE << "\n╔════════════════════╗\n"
              << "║      WELCOME       ║\n"
              << "╚════════════════════╝" << RESET << "\n";

    // options
    std::cout << "1. Register\n";
    std::cout << "2. Login\n";
    std::cout << "3. Exit\n";
    std::cout << YELLOW << "Select option: " << RESET;

    int choice;
    std::cin >> choice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    // route choice
    switch (choice)
    {
    case 1:
        handleRegister();
        break;
    case 2:
        handleLogin();
        break;
    case 3:
        exit(0); // exit program
    default:
        std::cout << RED << "Invalid option.\n"
                  << RESET;
    }
}

// main menu
void Menu::showMainMenu()
{
    const int width = 50; // total width of the box
    std::string title = "MAIN MENU (" + currentUser.getFullName() + ")";
    int padding = (width - 2 - title.size()) / 2; // subtract 2 for box edges

    // top border
    std::cout << GREEN << "\n╔";
    for (int i = 0; i < width - 2; ++i)
        std::cout << "═";
    std::cout << "╗\n";

    // title line
    std::cout << "║";
    for (int i = 0; i < padding; ++i)
        std::cout << " ";
    std::cout << title;
    for (int i = 0; i < width - 2 - padding - title.size(); ++i)
        std::cout << " ";
    std::cout << "║\n";

    // bottom border
    std::cout << "╚";
    for (int i = 0; i < width - 2; ++i)
        std::cout << "═";
    std::cout << "╝" << RESET << "\n";

    // menu options
    std::cout << " 1. Deposit\n"
              << " 2. Withdraw\n"
              << " 3. View Wallet\n"
              << " 4. Simulate Trades\n"
              << " 5. Recent Transactions\n"
              << " 6. User Statistics\n"
              << " 7. View Candlesticks\n"
              << " 8. Logout\n";
    std::cout << YELLOW << "Select option: " << RESET;

    int choice;
    std::cin >> choice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    // route choice
    switch (choice)
    {
    case 1:
        handleDeposit();
        break;
    case 2:
        handleWithdraw();
        break;
    case 3:
        handleViewWallet();
        break;
    case 4:
        handleSimulateTrades();
        break;
    case 5:
        handleViewTransactions();
        break;
    case 6:
        handlePrintStatistics();
        break;
    case 7:
        handleViewCandlesticks();
        break;
    case 8:
        loggedIn = false; // logout
        std::cout << BLUE << "Logged out.\n"
                  << RESET;
        break;
    default:
        std::cout << RED << "Invalid option.\n"
                  << RESET;
    }
}

// register action
void Menu::handleRegister()
{
    std::string name = promptString("Full Name: ");
    std::string email = promptString("Email: ");
    std::string password = promptString("Password: ");

    User newUser;
    if (userManager.registerUser(name, email, password, newUser))
    {
        std::cout << GREEN << "✔ User registered successfully! You can now login.\n"
                  << RESET;
    }
    else
    {
        std::cout << RED << "✖ Registration failed: user may already exist.\n"
                  << RESET;
    }
}

// login action
void Menu::handleLogin()
{
    // ask for email instead of internal user ID
    std::string email = promptString("Email: ");
    std::string password = promptString("Password: ");

    // loginUser should accept email now instead of userID
    if (userManager.loginUserByEmail(email, password, currentUser))
    {
        std::cout << GREEN << "✔ Login successful!\n"
                  << RESET;
        loggedIn = true;
    }
    else
    {
        std::cout << RED << "✖ Login failed: invalid credentials.\n"
                  << RESET;
    }
}

// deposit action
void Menu::handleDeposit()
{
    double amount = promptDouble("Amount to deposit: ");
    std::string asset = promptString("Asset (default USDT): ");
    if (asset.empty())
        asset = "USDT"; // default asset

    Wallet wallet = walletManager.loadWallet(currentUser.getUserID());
    if (walletManager.deposit(currentUser.getUserID(), wallet, amount, asset))
    {
        std::cout << GREEN << "✔ Deposit successful.\n"
                  << RESET;
    }
    else
    {
        std::cout << RED << "✖ Deposit failed.\n"
                  << RESET;
    }
}

// withdraw action
void Menu::handleWithdraw()
{
    double amount = promptDouble("Amount to withdraw: ");
    std::string asset = promptString("Asset (default USDT): ");
    if (asset.empty())
        asset = "USDT";

    Wallet wallet = walletManager.loadWallet(currentUser.getUserID());
    if (walletManager.withdraw(currentUser.getUserID(), wallet, amount, asset))
    {
        std::cout << GREEN << "✔ Withdrawal successful.\n"
                  << RESET;
    }
    else
    {
        std::cout << RED << "✖ Withdrawal failed: insufficient funds.\n"
                  << RESET;
    }
}

// view wallet
void Menu::handleViewWallet()
{
    Wallet wallet = walletManager.loadWallet(currentUser.getUserID());
    std::cout << BLUE << "\n--- Wallet Balances ---\n"
              << RESET;
    for (const auto &[currency, amount] : wallet.getAllBalances())
    {
        std::cout << "  • " << currency << ": " << amount << "\n";
    }
}

// simulate trades
void Menu::handleSimulateTrades()
{
    Wallet wallet = walletManager.loadWallet(currentUser.getUserID());
    TradeSimulator simulator(marketData, walletManager);
    simulator.simulateTrades(currentUser); // run simulation
    std::cout << GREEN << "✔ Simulated trades completed.\n"
              << RESET;
}

// view recent transactions
void Menu::handleViewTransactions()
{
    auto txs = walletManager.getRecentTransactions(currentUser.getUserID(), 5);
    std::cout << BLUE << "\n--- Last " << txs.size() << " Transactions ---\n"
              << RESET;

    // column widths 
    constexpr int textw = 9;
    constexpr int numw = 14;

    for (const auto &tx : txs)
    {
        std::cout << "  • "
                  << std::left << std::setw(3) << Transaction::typeToString(tx.type) << " | "
                  << std::left << std::setw(textw) << tx.product << " | "
                  << std::right << std::setw(numw) << std::fixed << std::setprecision(4)
                  << tx.amount << " | "
                  << std::right << std::setw(numw) << std::fixed << std::setprecision(4)
                  << tx.balanceAfter << " | "
                  << std::left << tx.timestamp
                  << std::endl;
    }
}

// print statistics
void Menu::handlePrintStatistics()
{
    std::cout << BLUE << "\n--- User Statistics ---\n"
              << RESET;
    walletManager.printStatistics(currentUser.getUserID());
}

// view candlesticks
void Menu::handleViewCandlesticks()
{
    std::vector<std::string> products = marketData.getAllProducts();
    if (products.empty())
    {
        std::cout << RED << "No products available.\n"
                  << RESET;
        return;
    }

    std::cout << BLUE << "Available products:\n"
              << RESET;
    for (size_t i = 0; i < products.size(); ++i)
        std::cout << "  " << i + 1 << ". " << products[i] << "\n";

    int choice;
    std::cout << YELLOW << "Select product: " << RESET;
    std::cin >> choice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    if (choice < 1 || choice > products.size())
    {
        std::cout << RED << "Invalid selection.\n"
                  << RESET;
        return;
    }

    std::string product = products[choice - 1];

    // select candlestick resolution (granularity)
    std::cout << BLUE << "\nSelect timeframe:\n"
              << RESET;
    std::cout << "  1. Yearly\n";
    std::cout << "  2. Daily\n";
    std::cout << "  3. Hourly\n";
    std::cout << "  4. Minutely\n";
    std::cout << "  5. Secondly\n";

    int tfChoice;
    std::cout << YELLOW << "Timeframe: " << RESET;
    std::cin >> tfChoice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    Timeframe timeframe;
    switch (tfChoice)
    {
        case 1: timeframe = Timeframe::Yearly;   break;
        case 2: timeframe = Timeframe::Daily;    break;
        case 3: timeframe = Timeframe::Hourly;   break;
        case 4: timeframe = Timeframe::Minutely; break;
        case 5: timeframe = Timeframe::Secondly; break;
        default:
            std::cout << RED << "Invalid timeframe.\n"
                      << RESET;
            return;
    }

    // compute candlesticks for chosen product + timeframe
    auto candles = marketData.computeCandlesticks(
        product,
        OrderBookType::ask,
        timeframe
    );

    if (candles.empty())
    {
        std::cout << RED << "No candlestick data available.\n"
                  << RESET;
        return;
    }

    // select how many results to display (prevent terminal spam)
    std::cout << BLUE << "\nDisplay how many candles:\n"
              << RESET;
    std::cout << "  1. Last 5\n";
    std::cout << "  2. Last 10\n";
    std::cout << "  3. Last 20\n";
    std::cout << "  4. Last 50\n";
    std::cout << "  5. All\n";

    int limitChoice;
    std::cout << YELLOW << "Selection: " << RESET;
    std::cin >> limitChoice;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    size_t limit;
    switch (limitChoice)
    {
        case 1: limit = 5;  break;
        case 2: limit = 10; break;
        case 3: limit = 20; break;
        case 4: limit = 50; break;
        case 5: limit = candles.size(); break;
        default:
            std::cout << RED << "Invalid selection.\n"
                      << RESET;
            return;
    }

    // determine starting index so we only print the most recent candles
    size_t start = (candles.size() > limit) ? candles.size() - limit : 0;

    std::cout << BLUE << "\n--- Candlesticks for " << product << " ---\n"
              << RESET;

    for (size_t i = start; i < candles.size(); ++i)
    {
        const auto &c = candles[i];
        std::cout << "  • " << CYAN << c.date << RESET
                  << " | O: " << GREEN << c.open << RESET
                  << " H: " << GREEN << c.high << RESET
                  << " L: " << RED   << c.low  << RESET
                  << " C: " << YELLOW << c.close << RESET
                  << std::endl;
    }
}


// prompt helpers
std::string Menu::promptString(const std::string &msg)
{
    std::cout << msg;
    std::string s;
    std::getline(std::cin, s); // read full line
    return s;
}

double Menu::promptDouble(const std::string &msg)
{
    double val;
    while (true)
    {
        std::cout << msg;
        std::cin >> val;
        if (!std::cin.fail())
        {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return val; // valid input
        }
        // input failed, clear and retry
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << RED << "Invalid number, try again.\n"
                  << RESET;
    }
}

==============================
FILE: Menu.h
==============================
#pragma once
#include "../user/UserManager.h"
#include "../wallet/WalletManager.h"
#include "../trading/TradeSimulator.h"
#include "../market/MarketDataLoader.h"
#include "../market/Candlestick.h"
#include <string>
#include <memory>
#include <vector>
#include <iomanip>

// personal implementation for this project
class Menu {
public:
    // constructor: store references to the main managers, no copies
    Menu(UserManager& userManager,
         WalletManager& walletManager,
         MarketDataLoader& marketData);

    // main loop: keeps showing menus until exit
    void run();

private:
    UserManager& userManager;
    WalletManager& walletManager;
    MarketDataLoader& marketData;

    User currentUser; // current logged-in user
    bool loggedIn = false; // login state

    // menus
    void showWelcomeMenu(); // login/register
    void showMainMenu(); // after login

    // actions 
    void handleRegister(); // register new user
    void handleLogin(); // login existing user
    void handleDeposit(); // deposit funds
    void handleWithdraw(); // withdraw funds
    void handleViewWallet(); // view wallet balances
    void handleSimulateTrades(); // run trade simulation
    void handleViewTransactions(); // last few transactions
    void handlePrintStatistics(); // user stats
    void handleViewCandlesticks(); // view candlestick chart for a product

    // helpers
    std::string promptString(const std::string& msg); // read line from stdin
    double promptDouble(const std::string& msg); // read double from stdin
};

==============================
FILE: User.cpp
==============================
#include "User.h"
#include <vector>

// personal implementation

// constructor just assigns all fields
User::User(const std::string& fullName,
           const std::string& email,
           const std::string& hashedPassword,
           const std::string& userID)
    : fullName(fullName),
      email(email),
      hashedPassword(hashedPassword),
      userID(userID)
{
}

// simple getters
std::string User::getUserID() const { return userID; }
std::string User::getFullName() const { return fullName; }
std::string User::getEmail() const { return email; }
std::string User::getHashedPassword() const { return hashedPassword; }

// convert user fields to csv row
std::vector<std::string> User::toCSVRow() const {
    return {userID, fullName, email, hashedPassword};
}

==============================
FILE: User.h
==============================
#pragma once
#include <string>
#include <vector>

// full file is personal implementation
class User {
public:
    User() = default;

    // constructor for creating a new user object
    User(const std::string& fullName,
         const std::string& email,
         const std::string& hashedPassword,
         const std::string& userID);

    // getters
    std::string getUserID() const;         // return unique 10-digit ID
    std::string getFullName() const;       // return full name
    std::string getEmail() const;          // return email
    std::string getHashedPassword() const; // return hashed password

    // convert user to csv row for saving
    std::vector<std::string> toCSVRow() const;

private:
    std::string userID;        // unique 10-digit ID
    std::string fullName;      // user's full name
    std::string email;         // user's email
    std::string hashedPassword; // hashed password using std::hash<string>
};

==============================
FILE: UserManager.cpp
==============================
#include "UserManager.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <random>
#include <functional> // std::hash

// personal implementation

// constructor just loads all users from csv
UserManager::UserManager(const std::string& userCSV)
    : userCSVFile(userCSV)
{
    loadUsers();
}

// load users from csv into vector
void UserManager::loadUsers() {
    std::ifstream file(userCSVFile);
    if (!file.is_open()) return; // nothing to load

    std::string line;
    while (std::getline(file, line)) {
        std::vector<std::string> tokens = CSVReader::tokenise(line, ',');
        if (tokens.size() != 4) continue; // skip malformed line

        // create user object and store in vector
        User user(tokens[1], tokens[2], tokens[3], tokens[0]);
        users.push_back(user);
    }
}

// append a single user to csv
void UserManager::saveUser(const User& user) {
    CSVReader::writeCSV(userCSVFile, {user.toCSVRow()}, true);
}

// check if user already exists by full name + email
bool UserManager::userExists(const std::string& fullName, const std::string& email) const {
    for (const auto& u : users) {
        if (u.getFullName() == fullName && u.getEmail() == email) return true;
    }
    return false;
}

// generate unique 10-digit ID for user
std::string UserManager::generateUniqueUserID() const {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 9);

    std::string id;
    bool unique = false;
    while (!unique) {
        id.clear();
        for (int i = 0; i < 10; ++i) id += std::to_string(dis(gen));

        // make sure id isn't already taken
        unique = true;
        for (const auto& u : users) {
            if (u.getUserID() == id) {
                unique = false;
                break;
            }
        }
    }
    return id;
}

// deterministic hash using std::hash with fixed seed
std::string UserManager::hashPassword(const std::string& password) const {
    // std::hash itself is called deterministically here
    std::hash<std::string> hasher;
    size_t rawHash = hasher(password);

    // convert to string using hex, ensures same result across platforms/runs
    std::stringstream ss;
    ss << std::hex << rawHash; 
    return ss.str();
}

// register a new user
bool UserManager::registerUser(const std::string& fullName,
                               const std::string& email,
                               const std::string& password,
                               User& outUser)
{
    if (userExists(fullName, email)) {
        std::cout << "User with this name and email already exists.\n";
        return false;
    }

    // generate id, hash password
    std::string userID = generateUniqueUserID();
    std::string hashedPassword = hashPassword(password);

    // create user object, store in memory and csv
    User newUser(fullName, email, hashedPassword, userID);
    users.push_back(newUser);
    saveUser(newUser);

    outUser = newUser; // return created user
    return true;
}

// login user by id + password
bool UserManager::loginUser(const std::string& userID,
                            const std::string& password,
                            User& outUser)
{
    std::string hashedInput = hashPassword(password);
    for (const auto& u : users) {
        if (u.getUserID() == userID && u.getHashedPassword() == hashedInput) {
            outUser = u;
            return true;
        }
    }
    return false;
}

// login by email
bool UserManager::loginUserByEmail(const std::string& email, const std::string& password, User& outUser)
{
    std::string hashedInput = hashPassword(password);
    for (const auto& u : users) {
        if (u.getEmail() == email && u.getHashedPassword() == hashedInput) {
            outUser = u;
            return true;
        }
    }
    return false;
}

// return all users in memory
std::vector<User> UserManager::getAllUsers() const {
    return users;
}

==============================
FILE: UserManager.h
==============================
#pragma once
#include "User.h"
#include "../core/CSVReader.h"
#include <string>
#include <vector>
#include <unordered_map>

// personal implementation
class UserManager {
public:
    UserManager(const std::string& userCSV); // load users from CSV on init

    // register a new user, returns false if duplicate
    bool registerUser(const std::string& fullName,
                      const std::string& email,
                      const std::string& password,
                      User& outUser);

    // login existing user by ID + password
    bool loginUser(const std::string& userID,
                   const std::string& password,
                   User& outUser);

    // login by email
    bool loginUserByEmail(const std::string& email, const std::string& password, User& outUser);

    // return all loaded users
    std::vector<User> getAllUsers() const;

private:
    std::string userCSVFile;     // csv file storing users
    std::vector<User> users;     // in-memory cache

    // helpers
    void loadUsers();                               // load from csv
    void saveUser(const User& user);               // append user to csv
    bool userExists(const std::string& fullName, const std::string& email) const; // check duplicates
    std::string generateUniqueUserID() const;      // generate unique 10-digit ID
    std::string hashPassword(const std::string& password) const; // hash password
};

==============================
FILE: Transaction.cpp
==============================
#include "Transaction.h"
#include <stdexcept> // for std::runtime_error


// personal implementation

// simple constructor, just assign everything
Transaction::Transaction(std::string userId,
                         TransactionType type,
                         std::string product,
                         double amount,
                         double balanceAfter,
                         std::string timestamp)
    : userId(userId),
      type(type),
      product(product),
      amount(amount),
      balanceAfter(balanceAfter),
      timestamp(timestamp)
{}

// convert transaction to a vector of strings for csv
std::vector<std::string> Transaction::toCSVRow() const
{
    return {
        userId,
        typeToString(type),       // convert enum to string
        product,
        std::to_string(amount),   // store amount
        std::to_string(balanceAfter),
        timestamp
    };
}

// rebuild a transaction from a csv row
Transaction Transaction::fromCSVRow(const std::vector<std::string>& row)
{
    return Transaction(
        row[0],                       // user id
        stringToType(row[1]),         // type
        row[2],                       // product
        std::stod(row[3]),            // amount
        std::stod(row[4]),            // balance after
        row[5]                        // timestamp
    );
}

// convert enum to string
std::string Transaction::typeToString(TransactionType type)
{
    switch (type)
    {
        case TransactionType::DEPOSIT:  return "DEPOSIT";
        case TransactionType::WITHDRAW: return "WITHDRAW";
        case TransactionType::ASK:      return "ASK";
        case TransactionType::BID:      return "BID";
    }
    return ""; // fallback
}

// convert string back to enum
TransactionType Transaction::stringToType(const std::string& str)
{
    if (str == "DEPOSIT")  return TransactionType::DEPOSIT;
    if (str == "WITHDRAW") return TransactionType::WITHDRAW;
    if (str == "ASK")      return TransactionType::ASK;
    if (str == "BID")      return TransactionType::BID;
    throw std::runtime_error("Invalid transaction type");
}

==============================
FILE: Transaction.h
==============================
#pragma once
#include <string>
#include <vector>

// personal implementation

// type of transaction
enum class TransactionType
{
    DEPOSIT,
    WITHDRAW,
    ASK,
    BID
};

// stores a single transaction
class Transaction
{
public:
    std::string userId;      // who did it
    TransactionType type;    // type of tx
    std::string product;     // currency or product
    double amount;           // how much involved
    double balanceAfter;     // wallet balance after tx
    std::string timestamp;   // when it happened

    // constructor
    Transaction(std::string userId,
                TransactionType type,
                std::string product,
                double amount,
                double balanceAfter,
                std::string timestamp);

    // convert to csv row (for saving)
    std::vector<std::string> toCSVRow() const;

    // rebuild transaction from csv row
    static Transaction fromCSVRow(const std::vector<std::string>& row);

    // helpers to convert type enum <-> string
    static std::string typeToString(TransactionType type);
    static TransactionType stringToType(const std::string& str);
};

==============================
FILE: Wallet.cpp
==============================
#include "Wallet.h"
#include <iostream>
#include "CSVReader.h"

Wallet::Wallet()
{


}

void Wallet::insertCurrency(std::string type, double amount)
{
    double balance;
    if (amount < 0)
    {
        throw std::exception{};
    }
    if (currencies.count(type) == 0) // not there yet
    {
        balance = 0;
    }
    else { // is there 
        balance = currencies[type];
    }
    balance += amount; 
    currencies[type] = balance; 
}

bool Wallet::removeCurrency(std::string type, double amount)
{
    if (amount < 0)
    {
        return false; 
    }
    if (currencies.count(type) == 0) // not there yet
    {
        //std::cout << "No currency for " << type << std::endl;
        return false;
    }
    else { // is there - do  we have enough
        if (containsCurrency(type, amount))// we have enough
        {
            //std::cout << "Removing " << type << ": " << amount << std::endl;
            currencies[type] -= amount;
            return true;
        } 
        else // they have it but not enough.
            return false; 
    }
}

bool Wallet::containsCurrency(std::string type, double amount)
{
    if (currencies.count(type) == 0) // not there yet
        return false;
    else 
        return currencies[type] >= amount;
    
}

double Wallet::getBalance(const std::string& type) const
{
    auto it = currencies.find(type);
    if (it != currencies.end()) return it->second; // return actual amount
    return 0.0;
}

std::string Wallet::toString()
{
    std::string s;
    for (std::pair<std::string,double> pair : currencies)
    {
        std::string currency = pair.first;
        double amount = pair.second;
        s += currency + " : " + std::to_string(amount) + "\n";
    }
    return s;
}

bool Wallet::canFulfillOrder(OrderBookEntry order)
{
    std::vector<std::string> currs = CSVReader::tokenise(order.product, '/');

    // ask / asksale: user must have enough of the first currency to sell
    if (order.orderType == OrderBookType::ask || order.orderType == OrderBookType::asksale)
    {
        double amount = order.amount;
        std::string currency = currs[0];
        std::cout << "Wallet::canFulfillOrder " << currency << " : " << amount << std::endl;
        return containsCurrency(currency, amount);
    }

    // bid / bidsale: user must have enough of the second currency to buy
    if (order.orderType == OrderBookType::bid || order.orderType == OrderBookType::bidsale)
    {
        double amount = order.amount * order.price;
        std::string currency = currs[1];
        std::cout << "Wallet::canFulfillOrder " << currency << " : " << amount << std::endl;
        return containsCurrency(currency, amount);
    }

    return false;
}
 

void Wallet::processSale(OrderBookEntry& sale)
{
    std::vector<std::string> currs = CSVReader::tokenise(sale.product, '/');
    // ask
    if (sale.orderType == OrderBookType::asksale)
    {
        double outgoingAmount = sale.amount;
        std::string outgoingCurrency = currs[0];
        double incomingAmount = sale.amount * sale.price;
        std::string incomingCurrency = currs[1];

        currencies[incomingCurrency] += incomingAmount;
        currencies[outgoingCurrency] -= outgoingAmount;

    }
    // bid
    if (sale.orderType == OrderBookType::bidsale)
    {
        double incomingAmount = sale.amount;
        std::string incomingCurrency = currs[0];
        double outgoingAmount = sale.amount * sale.price;
        std::string outgoingCurrency = currs[1];

        currencies[incomingCurrency] += incomingAmount;
        currencies[outgoingCurrency] -= outgoingAmount;
    }
}
std::ostream& operator<<(std::ostream& os,  Wallet& wallet)
{
    os << wallet.toString();
    return os;
}


==============================
FILE: Wallet.h
==============================
#pragma once

#include <string>
#include <map>
#include "../market/OrderBookEntry.h"
#include <iostream>

// reused code
class Wallet 
{
public:
    Wallet();
    void insertCurrency(std::string type, double amount);
    bool removeCurrency(std::string type, double amount);
    bool containsCurrency(std::string type, double amount);
    bool canFulfillOrder(OrderBookEntry order);
    void processSale(OrderBookEntry& sale);
    std::string toString();
    friend std::ostream& operator<<(std::ostream& os, Wallet& wallet);

    // get balance in usdt
    double getBalance(const std::string& type) const;
    // get all balances as a map, needed for WalletManager saveWallet
    const std::map<std::string, double> getAllBalances() const
    {
        return currencies; // just return a copy
    }

private:
    std::map<std::string,double> currencies;
};

==============================
FILE: WalletManager.cpp
==============================
#include "WalletManager.h"
#include <iostream>
#include <ctime>
#include <fstream>   // for ifstream
#include <string>    // for std::string

// personal implementation


// just assign filenames
WalletManager::WalletManager(const std::string& walletFile,
                             const std::string& transactionFile)
    : walletsCSV(walletFile),
      transactionsCSV(transactionFile)
{}

// load wallet for user
Wallet WalletManager::loadWallet(const std::string& userId)
{
    Wallet wallet;
    std::ifstream file(walletsCSV);
    std::string line;

    while (std::getline(file, line))
    {
        auto tokens = CSVReader::tokenise(line, ',');
        if (tokens[0] == userId)
        {
            wallet.insertCurrency(tokens[1], std::stod(tokens[2]));
        }
    }
    return wallet;
}

// save wallet
void WalletManager::saveWallet(const std::string& userId, Wallet& wallet)
{
    std::ifstream in(walletsCSV);
    std::vector<std::vector<std::string>> rows;
    std::string line;

    // keep all other users
    while (std::getline(in, line))
    {
        auto tokens = CSVReader::tokenise(line, ',');
        if (tokens[0] != userId)
            rows.push_back(tokens);
    }

    // write updated balances for all currencies in this wallet
    auto balances = wallet.getAllBalances();
    for (const auto& [currency, amount] : balances) 
    {
        rows.push_back({
            userId,
            currency,
            std::to_string(amount)
        });
    }

    CSVReader::writeCSV(walletsCSV, rows, false); // overwrite
}


// deposit funds into wallet, log tx
bool WalletManager::deposit(const std::string& userId,
                            Wallet& wallet,
                            double amount,
                            const std::string& asset)
{
    if (amount <= 0) return false; // reject bad amounts

    wallet.insertCurrency(asset, amount); // add to wallet
    saveWallet(userId, wallet);

    auto now = std::time(nullptr);

    // get actual balance after deposit once
    double balanceAfter = wallet.getBalance(asset); 

    Transaction tx(userId, TransactionType::DEPOSIT,
                   asset,
                   amount,
                   balanceAfter,
                   std::ctime(&now));

    // append to history
    logTransaction(tx); 
    return true;
}


// withdraw funds from wallet, log tx
bool WalletManager::withdraw(const std::string& userId,
                             Wallet& wallet,
                             double amount,
                             const std::string& asset)
{
    if (!wallet.removeCurrency(asset, amount)) return false; // not enough
    saveWallet(userId, wallet);

    auto now = std::time(nullptr);

    double balanceAfter = wallet.getBalance(asset); // correct balance

    Transaction tx(userId,
                   TransactionType::WITHDRAW,
                   asset,
                   amount,
                   balanceAfter,
                   std::ctime(&now));

    logTransaction(tx);
    return true;
}

// append transaction to csv
void WalletManager::logTransaction(const Transaction& tx)
{
    CSVReader::writeCSV(
        transactionsCSV,
        {tx.toCSVRow()},
        true
    );
}

// load all transactions from file
std::vector<Transaction> WalletManager::loadAllTransactions()
{
    std::ifstream file(transactionsCSV);
    std::vector<Transaction> result;
    std::string line;

    while (std::getline(file, line))
    {
        auto tokens = CSVReader::tokenise(line, ',');
        if (tokens.size() == 6)
            result.push_back(Transaction::fromCSVRow(tokens));
    }
    return result;
}

// get last n transactions for a user
std::vector<Transaction> WalletManager::getRecentTransactions(
    const std::string& userId,
    int count)
{
    auto all = loadAllTransactions();
    std::vector<Transaction> filtered;

    // filter for user
    for (auto& tx : all)
        if (tx.userId == userId)
            filtered.push_back(tx);

    // return last count
    if (filtered.size() <= count) return filtered;

    return std::vector<Transaction>(
        filtered.end() - count,
        filtered.end()
    );
}

// compute some stats for a user
void WalletManager::printStatistics(const std::string& userId,
                                    const std::string& productFilter)
{
    auto all = loadAllTransactions();

    int asks = 0, bids = 0;
    double totalSpent = 0.0;

    for (const auto& tx : all)
    {
        if (tx.userId != userId) continue;            // skip others
        if (!productFilter.empty() && tx.product != productFilter) continue; // filter

        if (tx.type == TransactionType::ASK) asks++;
        if (tx.type == TransactionType::BID) bids++;

        // only count outgoing money (withdrawals, asks, bids), not deposits
        if (tx.type == TransactionType::WITHDRAW || tx.type == TransactionType::ASK || tx.type == TransactionType::BID)
            totalSpent += tx.amount;
    }

    // print stats
    std::cout << "ASKS: " << asks << "\n";
    std::cout << "BIDS: " << bids << "\n";
    std::cout << "TOTAL SPENT: " << totalSpent << "\n";
}

==============================
FILE: WalletManager.h
==============================
#pragma once
#include "Wallet.h"
#include "Transaction.h"
#include "../core/CSVReader.h"
#include "../core/DateUtils.h"
#include <vector>

// personal implementation: manages wallets + transaction history
class WalletManager
{
public:
    WalletManager(const std::string& walletFile,
                  const std::string& transactionFile);

    // load a wallet from csv
    Wallet loadWallet(const std::string& userId);

    // save current wallet state
    void saveWallet(const std::string& userId, Wallet& wallet);

    // deposit and log (multi-asset; default = USDT)
    bool deposit(const std::string& userId, 
                 Wallet& wallet, 
                 double amount,
                 const std::string& asset = "USDT");

    // withdraw and log (multi-asset; default = USDT)
    bool withdraw(const std::string& userId, 
                  Wallet& wallet, 
                  double amount,
                  const std::string& asset = "USDT");

    // get last n transactions
    std::vector<Transaction> getRecentTransactions(
        const std::string& userId,
        int count = 5
    );

    // compute simple stats for a user
    void printStatistics(const std::string& userId,
                         const std::string& productFilter = "");
    
    // helper: append transaction to csv
    void logTransaction(const Transaction& tx);

private:
    std::string walletsCSV;        // where wallets are saved
    std::string transactionsCSV;   // transaction log

    // load all transactions
    std::vector<Transaction> loadAllTransactions();
};
