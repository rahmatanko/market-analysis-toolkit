
==============================
FILE: CSVReader.cpp
==============================
#include "CSVReader.h"
#include <iostream>
#include <fstream>
#include <sstream>

// read the market CSV file and convert each line to OrderBookEntry
// starter code
std::vector<OrderBookEntry> CSVReader::readMarketCSV(const std::string& filename)
{
    std::vector<OrderBookEntry> entries; // this will hold all the entries from the CSV

    std::ifstream csvFile{filename}; // open the file
    std::string line;
    if (csvFile.is_open())
    {
        while(std::getline(csvFile, line)) // read line by line
        {
            try {
                // convert line to tokens, then tokens to OrderBookEntry
                OrderBookEntry obe = stringsToOBE(tokenise(line, ','));
                entries.push_back(obe); // add to our vector
            }catch(const std::exception& e)
            {
                // if the line is malformed, just print a message and skip it
                std::cout << "CSVReader::readCSV bad data"  << std::endl;
            }
        }
    }    

    // print how many entries we successfully read
    std::cout << "CSVReader::readCSV read " << entries.size() << " entries"  << std::endl;
    return entries; 
}

// split a line into tokens based on separator, e.g. ','
// starter code
std::vector<std::string> CSVReader::tokenise(const std::string& line, char separator)
{
    std::vector<std::string> tokens; // output vector
    signed int start, end;
    std::string token;

    start = line.find_first_not_of(separator, 0); // skip any leading separators
    do{
        end = line.find_first_of(separator, start); // find next separator
        if (start == line.length() || start == end) break; // nothing left to parse
        if (end >= 0) token = line.substr(start, end - start); // extract token
        else token = line.substr(start, line.length() - start); // last token
        tokens.push_back(token); // add to vector
        start = end + 1; // move past the separator
    }while(end > 0);

    return tokens; 
}

// convert a vector of strings into OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(const std::vector<std::string>& tokens)
{
    double price, amount;

    if (tokens.size() != 5) // not enough or too many tokens
    {
        std::cout << "Bad line " << std::endl;
        throw std::exception{};
    }

    // parse price and amount, might throw
    try {
        price = std::stod(tokens[3]);
        amount = std::stod(tokens[4]);
    }catch(const std::exception& e){
        std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[3]<< std::endl;
        std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[4]<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       tokens[0], // timestamp
                       tokens[1], // product
                       OrderBookEntry::stringToOrderBookType(tokens[2])}; // order type

    return obe; 
}

// convert individual strings to OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType)
{
    double price, amount;

    try {
        price = std::stod(priceString); // convert price to double
        amount = std::stod(amountString); // convert amount to double
    }catch(const std::exception& e){
        std::cout << "CSVReader::stringsToOBE Bad float! " << priceString<< std::endl;
        std::cout << "CSVReader::stringsToOBE Bad float! " << amountString<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       timestamp,
                       product, 
                       orderType};
                
    return obe;
}

// write any csv data to a file, append or overwrite
// personal implementation
void CSVReader::writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append)
{
    // open the file in append or truncate mode
    std::ofstream file(filename, append ? std::ios::app : std::ios::trunc);
    if (!file.is_open()) {
        std::cerr << "Failed to open CSV file: " << filename << std::endl;
        return; // can't continue
    }

    // write each row
    for (const auto& row : data) {
        for (size_t i = 0; i < row.size(); ++i) {
            file << row[i]; // write the cell
            if (i < row.size() - 1) file << ","; // add comma between columns
        }
        file << "\n"; // end of row
    }
}

==============================
FILE: CSVReader.h
==============================
#pragma once
#include "../market/OrderBookEntry.h"
#include <vector>
#include <string>

class CSVReader {
public:
    // constructor, nothing special here
    CSVReader() {}  // trivial constructor

    // read the market csv into a vector of OrderBookEntry objects
    // starter code
    static std::vector<OrderBookEntry> readMarketCSV(const std::string& filename);

    // split a line into tokens based on separator, e.g. ','
    // starter code
    static std::vector<std::string> tokenise(const std::string& line, char separator);

    // convert a vector of strings into an OrderBookEntry
    // starter code
    static OrderBookEntry stringsToOBE(const std::vector<std::string>& tokens);

    // convert individual strings into an OrderBookEntry
    // starter code
    OrderBookEntry stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType);

    // write any csv data to a file
    // personal implementation
    static void writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append = true);
};

==============================
FILE: DateUtils.cpp
==============================
#include "DateUtils.h"
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm> 

// convert "YYYY-MM-DD" or "YYYY/MM/DD HH:MM:SS(.micro)" string to tm struct
// personal implementation
std::tm DateUtils::stringToTm(const std::string& dateStr)
{
    std::tm timeStruct = {};
    std::string cleanedStr = dateStr;

    // strip fractional seconds if present (after dot)
    auto dotPos = cleanedStr.find('.');
    if (dotPos != std::string::npos) {
        cleanedStr = cleanedStr.substr(0, dotPos); // remove microseconds
    }

    // replace '/' with '-' to handle both formats
    std::replace(cleanedStr.begin(), cleanedStr.end(), '/', '-');

    // parse using standard YYYY-MM-DD HH:MM:SS format
    std::istringstream ss(cleanedStr);
    ss >> std::get_time(&timeStruct, "%Y-%m-%d %H:%M:%S");
    if (ss.fail()) {
        // parsing failed: maybe only date without time
        ss.clear();
        ss.str(cleanedStr);
        ss >> std::get_time(&timeStruct, "%Y-%m-%d");
        if (ss.fail()) {
            std::cerr << "DateUtils::stringToTm failed to parse: " << dateStr << std::endl;
        }
    }

    // tm_mon is 0-indexed, tm_mday is fine
    return timeStruct;
}

// convert tm struct back to "YYYY-MM-DD HH:MM:SS"
std::string DateUtils::tmToString(const std::tm& timeStruct)
{
    std::ostringstream ss;
    ss << std::put_time(&timeStruct, "%Y-%m-%d %H:%M:%S"); // simple formatting
    return ss.str();
}

// get year from tm
int DateUtils::getYear(const std::tm& timeStruct)
{
    return timeStruct.tm_year + 1900; // tm_year = years since 1900
}

// get month from tm
int DateUtils::getMonth(const std::tm& timeStruct)
{
    return timeStruct.tm_mon + 1; // tm_mon = 0..11
}

// get day from tm
int DateUtils::getDay(const std::tm& timeStruct)
{
    return timeStruct.tm_mday; // tm_mday = 1..31
}

// returns true if date1 <= date2
bool DateUtils::isBeforeOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) < getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) < getMonth(date2);
    return getDay(date1) <= getDay(date2);
}

// returns true if date1 >= date2
bool DateUtils::isAfterOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) > getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) > getMonth(date2);
    return getDay(date1) >= getDay(date2);
}

==============================
FILE: DateUtils.h
==============================
#pragma once
#include <string>
#include <ctime>

// personal implementation
// utility functions for date parsing, extraction, and comparison
class DateUtils {
public:
    DateUtils() {}

    // convert a timestamp string "YYYY-MM-DD" → tm struct
    static std::tm stringToTm(const std::string& dateStr);

    // convert a tm struct back to string "YYYY-MM-DD"
    static std::string tmToString(const std::tm& timeStruct);

    // extract year from tm
    static int getYear(const std::tm& timeStruct);

    // extract month from tm
    static int getMonth(const std::tm& timeStruct);

    // extract day from tm
    static int getDay(const std::tm& timeStruct);

    // compare two dates, returns true if date1 <= date2
    static bool isBeforeOrEqual(const std::tm& date1, const std::tm& date2);

    // compare two dates, returns true if date1 >= date2
    static bool isAfterOrEqual(const std::tm& date1, const std::tm& date2);
};

==============================
FILE: main.cpp
==============================
#include "core/CSVReader.h"
#include "core/DateUtils.h"
#include <iostream>
#include <vector>

int main() {
    // Phase 0 test harness: read CSV, filter by date, write CSV
    std::cout << "[PHASE 0] Starting test of CSVReader + DateUtils\n";

    // ----- read market CSV -----
    std::string filename = "data/small_market_data.csv"; // 
    std::vector<OrderBookEntry> entries = CSVReader::readMarketCSV(filename);
    std::cout << "[INFO] Total entries read: " << entries.size() << "\n";

    // ----- define date range for filtering -----
    std::string startStr = "2023-06-01"; // filter start date
    std::string endStr   = "2023-06-03"; // filter end date

    std::tm startDate = DateUtils::stringToTm(startStr);
    std::tm endDate   = DateUtils::stringToTm(endStr);

    std::cout << "[INFO] Filtering entries from " << startStr 
              << " to " << endStr << "\n";

    // ----- loop through entries and filter -----
    std::vector<OrderBookEntry> filteredEntries;
    for (auto& e : entries) {
        std::tm tradeDate = DateUtils::stringToTm(e.timestamp);

        if (DateUtils::isAfterOrEqual(tradeDate, startDate) &&
            DateUtils::isBeforeOrEqual(tradeDate, endDate)) {
            // this trade is within the range, include it
            filteredEntries.push_back(e);
        }
    }

    std::cout << "[INFO] Entries after filtering: " << filteredEntries.size() << "\n";

    // ----- print filtered entries -----
    for (auto& e : filteredEntries) {
        std::cout << e.timestamp << " | "
                  << e.product << " | "
                  << (e.orderType == OrderBookType::ask ? "ask" : "bid") 
                  << " | " << e.price << " | " << e.amount << "\n";
    }

    // ----- write filtered entries to CSV -----
    std::vector<std::vector<std::string>> csvData;
    for (auto& e : filteredEntries) {
        csvData.push_back({
            e.timestamp,
            e.product,
            (e.orderType == OrderBookType::ask ? "ask" : "bid"),
            std::to_string(e.price),
            std::to_string(e.amount)
        });
    }

    std::string outFile = "data/phase0_filtered.csv";
    CSVReader::writeCSV(outFile, csvData, false); // overwrite file
    std::cout << "[INFO] Filtered CSV written to " << outFile << "\n";

    std::cout << "[PHASE 0] Test complete!\n";
    return 0;
}

==============================
FILE: OrderBookEntry.cpp
==============================
#include "OrderBookEntry.h"

// starter code – initializes a market order entry
OrderBookEntry::OrderBookEntry(double _price,
                               double _amount,
                               std::string _timestamp,
                               std::string _product,
                               OrderBookType _orderType,
                               std::string _username)
    : price(_price),
      amount(_amount),
      timestamp(_timestamp),
      product(_product),
      orderType(_orderType),
      username(_username)
{
    // nothing else to do here
}

// starter code – convert string from CSV → enum type
OrderBookType OrderBookEntry::stringToOrderBookType(std::string s) {
    if (s == "ask") {
        return OrderBookType::ask;
    }
    if (s == "bid") {
        return OrderBookType::bid;
    }
    // fallback for unknown/unsupported types
    return OrderBookType::unknown;
}

==============================
FILE: OrderBookEntry.h
==============================
#pragma once
#include <string>

// starter code – represents one market order
enum class OrderBookType { bid, ask, unknown, asksale, bidsale };

class OrderBookEntry {
public:
    // constructor – creates a trade/order object
    OrderBookEntry(double _price,
                   double _amount,
                   std::string _timestamp,
                   std::string _product,
                   OrderBookType _orderType,
                   std::string username = "dataset");

    // helper: convert string to enum
    static OrderBookType stringToOrderBookType(std::string s);

    // sorting helpers
    static bool compareByTimestamp(OrderBookEntry& e1, OrderBookEntry& e2) {
        // orders sorted earliest → latest
        return e1.timestamp < e2.timestamp;
    }

    static bool compareByPriceAsc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // low → high price
        return e1.price < e2.price;
    }

    static bool compareByPriceDesc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // high → low price
        return e1.price > e2.price;
    }

    // core order properties
    double price;            // order price
    double amount;           // order amount
    std::string timestamp;   // string timestamp e.g. "2020-03-17 12:00:00"
    std::string product;     // product pair e.g. "ETH/USDT"
    OrderBookType orderType; // bid / ask / etc.
    std::string username;    // source of the order
};
