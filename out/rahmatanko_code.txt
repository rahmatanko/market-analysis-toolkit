
==============================
FILE: CSVReader.cpp
==============================
#include "CSVReader.h"
#include <iostream>
#include <fstream>
#include <sstream>

// read the market CSV file and convert each line to OrderBookEntry
// starter code
std::vector<OrderBookEntry> CSVReader::readMarketCSV(const std::string& filename)
{
    std::vector<OrderBookEntry> entries; // this will hold all the entries from the CSV

    std::ifstream csvFile{filename}; // open the file
    std::string line;
    int lineNum = 0; // keep track of the line number
    if (csvFile.is_open())
    {
        while(std::getline(csvFile, line)) // read line by line
        {
            ++lineNum;
            std::vector<std::string> tokens = tokenise(line, ',');
            
            // skip malformed lines
            if (tokens.size() != 5) {
                std::cout << "CSVReader::readMarketCSV bad data (wrong token count) at line " << lineNum << std::endl;
                continue; // skip this line
            }

            try {
                // convert line to tokens, then tokens to OrderBookEntry
                OrderBookEntry obe = stringsToOBE(tokens);
                entries.push_back(obe); // add to our vector
            } catch(const std::exception& e)
            {
                // if the line has invalid floats, just print a message and skip it
                std::cout << "CSVReader::readMarketCSV bad data (invalid float) at line " << lineNum << std::endl;
                continue; // skip this line
            }
        }
    }    

    // print how many entries we successfully read
    std::cout << "CSVReader::readMarketCSV read " << entries.size() << " entries"  << std::endl;
    return entries; 
}


// split a line into tokens based on separator, e.g. ','
// starter code
std::vector<std::string> CSVReader::tokenise(const std::string& line, char separator)
{
    std::vector<std::string> tokens; // output vector
    signed int start, end;
    std::string token;

    start = line.find_first_not_of(separator, 0); // skip any leading separators
    do{
        end = line.find_first_of(separator, start); // find next separator
        if (start == line.length() || start == end) break; // nothing left to parse
        if (end >= 0) token = line.substr(start, end - start); // extract token
        else token = line.substr(start, line.length() - start); // last token
        tokens.push_back(token); // add to vector
        start = end + 1; // move past the separator
    }while(end > 0);

    return tokens; 
}

// convert a vector of strings into OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(const std::vector<std::string>& tokens)
{
    double price, amount;

    if (tokens.size() != 5) // not enough or too many tokens
    {
        std::cout << "Bad line " << std::endl;
        throw std::exception{};
    }

    // parse price and amount, might throw
    try {
        price = std::stod(tokens[3]);
        amount = std::stod(tokens[4]);
    }catch(const std::exception& e){
        std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[3]<< std::endl;
        std::cout << "CSVReader::stringsToOBE Bad float! " << tokens[4]<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       tokens[0], // timestamp
                       tokens[1], // product
                       OrderBookEntry::stringToOrderBookType(tokens[2])}; // order type

    return obe; 
}

// convert individual strings to OrderBookEntry
// starter code
OrderBookEntry CSVReader::stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType)
{
    double price, amount;

    try {
        price = std::stod(priceString); // convert price to double
        amount = std::stod(amountString); // convert amount to double
    }catch(const std::exception& e){
        std::cout << "CSVReader::stringsToOBE Bad float! " << priceString<< std::endl;
        std::cout << "CSVReader::stringsToOBE Bad float! " << amountString<< std::endl; 
        throw;        
    }

    // create the OrderBookEntry object
    OrderBookEntry obe{price, 
                       amount, 
                       timestamp,
                       product, 
                       orderType};
                
    return obe;
}

// write any csv data to a file, append or overwrite
// personal implementation
void CSVReader::writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append)
{
    // open the file in append or truncate mode
    std::ofstream file(filename, append ? std::ios::app : std::ios::trunc);
    if (!file.is_open()) {
        std::cerr << "Failed to open CSV file: " << filename << std::endl;
        return; // can't continue
    }

    // write each row
    for (const auto& row : data) {
        for (size_t i = 0; i < row.size(); ++i) {
            file << row[i]; // write the cell
            if (i < row.size() - 1) file << ","; // add comma between columns
        }
        file << "\n"; // end of row
    }
}

==============================
FILE: CSVReader.h
==============================
#pragma once
#include "../market/OrderBookEntry.h"
#include <vector>
#include <string>

class CSVReader {
public:
    // constructor, nothing special here
    CSVReader() {}  // trivial constructor

    // read the market csv into a vector of OrderBookEntry objects
    // starter code
    static std::vector<OrderBookEntry> readMarketCSV(const std::string& filename);

    // split a line into tokens based on separator, e.g. ','
    // starter code
    static std::vector<std::string> tokenise(const std::string& line, char separator);

    // convert a vector of strings into an OrderBookEntry
    // starter code
    static OrderBookEntry stringsToOBE(const std::vector<std::string>& tokens);

    // convert individual strings into an OrderBookEntry
    // starter code
    OrderBookEntry stringsToOBE(std::string priceString, 
                                       std::string amountString, 
                                       std::string timestamp, 
                                       std::string product, 
                                       OrderBookType orderType);

    // write any csv data to a file
    // personal implementation
    static void writeCSV(const std::string& filename,
                         const std::vector<std::vector<std::string>>& data,
                         bool append = true);
};

==============================
FILE: DateUtils.cpp
==============================
#include "DateUtils.h"
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm> 

// convert "YYYY-MM-DD" or "YYYY/MM/DD HH:MM:SS(.micro)" string to tm struct
// personal implementation
std::tm DateUtils::stringToTm(const std::string& dateStr)
{
    std::tm timeStruct = {};
    std::string cleanedStr = dateStr;

    // strip fractional seconds if present (after dot)
    auto dotPos = cleanedStr.find('.');
    if (dotPos != std::string::npos) {
        cleanedStr = cleanedStr.substr(0, dotPos); // remove microseconds
    }

    // replace '/' with '-' to handle both formats
    std::replace(cleanedStr.begin(), cleanedStr.end(), '/', '-');

    // parse using standard YYYY-MM-DD HH:MM:SS format
    std::istringstream ss(cleanedStr);
    ss >> std::get_time(&timeStruct, "%Y-%m-%d %H:%M:%S");
    if (ss.fail()) {
        // parsing failed: maybe only date without time
        ss.clear();
        ss.str(cleanedStr);
        ss >> std::get_time(&timeStruct, "%Y-%m-%d");
        if (ss.fail()) {
            std::cerr << "DateUtils::stringToTm failed to parse: " << dateStr << std::endl;
        }
    }

    // tm_mon is 0-indexed, tm_mday is fine
    return timeStruct;
}

// convert tm struct back to "YYYY-MM-DD HH:MM:SS"
std::string DateUtils::tmToString(const std::tm& timeStruct)
{
    std::ostringstream ss;
    ss << std::put_time(&timeStruct, "%Y-%m-%d %H:%M:%S"); // simple formatting
    return ss.str();
}

// get year from tm
int DateUtils::getYear(const std::tm& timeStruct)
{
    return timeStruct.tm_year + 1900; // tm_year = years since 1900
}

// get month from tm
int DateUtils::getMonth(const std::tm& timeStruct)
{
    return timeStruct.tm_mon + 1; // tm_mon = 0..11
}

// get day from tm
int DateUtils::getDay(const std::tm& timeStruct)
{
    return timeStruct.tm_mday; // tm_mday = 1..31
}

// returns true if date1 <= date2
bool DateUtils::isBeforeOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) < getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) < getMonth(date2);
    return getDay(date1) <= getDay(date2);
}

// returns true if date1 >= date2
bool DateUtils::isAfterOrEqual(const std::tm& date1, const std::tm& date2)
{
    if (getYear(date1) != getYear(date2)) return getYear(date1) > getYear(date2);
    if (getMonth(date1) != getMonth(date2)) return getMonth(date1) > getMonth(date2);
    return getDay(date1) >= getDay(date2);
}

==============================
FILE: DateUtils.h
==============================
#pragma once
#include <string>
#include <ctime>

// personal implementation
// utility functions for date parsing, extraction, and comparison
class DateUtils {
public:
    DateUtils() {}

    // convert a timestamp string "YYYY-MM-DD" → tm struct
    static std::tm stringToTm(const std::string& dateStr);

    // convert a tm struct back to string "YYYY-MM-DD"
    static std::string tmToString(const std::tm& timeStruct);

    // extract year from tm
    static int getYear(const std::tm& timeStruct);

    // extract month from tm
    static int getMonth(const std::tm& timeStruct);

    // extract day from tm
    static int getDay(const std::tm& timeStruct);

    // compare two dates, returns true if date1 <= date2
    static bool isBeforeOrEqual(const std::tm& date1, const std::tm& date2);

    // compare two dates, returns true if date1 >= date2
    static bool isAfterOrEqual(const std::tm& date1, const std::tm& date2);
};

==============================
FILE: main.cpp
==============================
#include <iostream>
#include <vector>
#include "market/MarketDataLoader.h"

// this main file tests hourly, minutely, and secondly candlesticks
int main()
{
    // path to the market csv
    std::string csvFile = "data/small_market_data.csv";

    // construct the loader (reads + stores all orders internally)
    MarketDataLoader loader(csvFile);

    // product + order type to test with
    std::string product = "ETH/BTC";
    OrderBookType type = OrderBookType::ask;

    // define the three granularities we want to test
    std::vector<Timeframe> timeframes = {
        Timeframe::Hourly,
        Timeframe::Minutely,
        Timeframe::Secondly
    };

    // loop through each timeframe and print its candles
    for (Timeframe tf : timeframes)
    {
        // compute candlesticks for this timeframe
        std::vector<Candlestick> candles =
            loader.computeCandlesticks(product, type, tf);

        // quick sanity check
        if (candles.empty())
        {
            std::cout << "no candlesticks for timeframe " << static_cast<int>(tf) << "\n";
            continue;
        }

        // print a header for clarity
        std::string label = (tf == Timeframe::Hourly) ? "hourly" :
                            (tf == Timeframe::Minutely) ? "minutely" :
                            "secondly";

        std::cout << "\n--- " << label << " candlesticks ---\n";
        std::cout << "date, open, high, low, close\n";

        // loop through all candles for this timeframe
        for (const Candlestick& c : candles)
        {
            std::cout << c.date << ", "
                      << c.open << ", "
                      << c.high << ", "
                      << c.low << ", "
                      << c.close << "\n";
        }
    }

    // done, all buckets printed
    return 0;
}

==============================
FILE: Candlestick.cpp
==============================
#include "Candlestick.h"
#include <algorithm>

Candlestick::Candlestick(std::string date,
                         double open,
                         double high,
                         double low,
                         double close)
    : date(date),
      open(open),
      high(high),
      low(low),
      close(close)
{
    // nothing else to do here
}

// personal implementation
// prices are assumed to be ordered from earliest → latest
Candlestick Candlestick::compute(const std::string& date,
                                 const std::vector<double>& prices)
{
    // open is the first trade price in this period
    double open = prices.front();

    // close is the last trade price in this period
    double close = prices.back();

    // highest traded price in this period
    double high = *std::max_element(prices.begin(), prices.end());

    // lowest traded price in this period
    double low = *std::min_element(prices.begin(), prices.end());

    // return a fully constructed candlestick object
    return Candlestick(date, open, high, low, close);
}

==============================
FILE: Candlestick.h
==============================
#pragma once
#include <string>
#include <vector>

// represents one OHLC summary for a single time bucket (day / month / year)
// used in task 1 for candlestick computation
class Candlestick
{
public:
    // date string depends on timeframe:
    // YYYY (yearly), YYYY-MM (monthly), YYYY-MM-DD (daily)
    std::string date;

    // open: first price in the time bucket
    // high: max price in the time bucket
    // low: min price in the time bucket
    // close: last price in the time bucket
    double open;
    double high;
    double low;
    double close;

    // simple constructor, just assigns values
    Candlestick(std::string date,
                double open,
                double high,
                double low,
                double close);

    // personal implementation
    // computes OHLC values from a list of prices already in chronological order
    static Candlestick compute(const std::string& date,
                               const std::vector<double>& prices);
};

==============================
FILE: MarketDataLoader.cpp
==============================
#include "MarketDataLoader.h"
#include "../core/CSVReader.h"
#include "../core/DateUtils.h"

// reuses the provided CSVReader to load market data
MarketDataLoader::MarketDataLoader(const std::string& marketCSV)
{
    // market csv is read once and cached in memory
    orders = CSVReader::readMarketCSV(marketCSV);
}

std::vector<Candlestick> MarketDataLoader::computeCandlesticks(
    const std::string& product,
    OrderBookType type,
    Timeframe timeframe)
{
    // map used to group prices by date bucket
    // key   → date string (e.g. 2023-06-01)
    // value → list of prices in chronological order
    std::map<std::string, std::vector<double>> buckets;

    // filter orders by product and order type
    for (const OrderBookEntry& e : orders)
    {
        if (e.product == product && e.orderType == type)
        {
            // determine which bucket this order belongs to
            std::string bucket = getTimeBucket(e.timestamp, timeframe);

            // add price to the corresponding bucket
            buckets[bucket].push_back(e.price);
        }
    }

    std::vector<Candlestick> result;

    // compute OHLC values for each bucket
    for (const auto& pair : buckets)
    {
        result.push_back(
            Candlestick::compute(pair.first, pair.second)
        );
    }

    return result;
}

// personal implementation
// converts a timestamp string into a date bucket string
std::string MarketDataLoader::getTimeBucket(const std::string& timestamp,
                                            Timeframe timeframe)
{
    // parse timestamp into tm struct using shared utility
    std::tm time = DateUtils::stringToTm(timestamp);

    int year  = DateUtils::getYear(time);  // extract year
    int month = DateUtils::getMonth(time); // extract month
    int day   = DateUtils::getDay(time);   // extract day
    int hour  = time.tm_hour;              // extract hour
    int min   = time.tm_min;               // extract minute
    int sec   = time.tm_sec;               // extract second

    // helper for two-digit formatting
    auto twoDigits = [](int x){ return (x < 10 ? "0" : "") + std::to_string(x); };

    if (timeframe == Timeframe::Yearly)
    {
        // yearly bucket: YYYY
        return std::to_string(year);
    }

    if (timeframe == Timeframe::Monthly)
    {
        // monthly bucket: YYYY-MM
        return std::to_string(year) + "-" + twoDigits(month);
    }

    if (timeframe == Timeframe::Daily)
    {
        // daily bucket: YYYY-MM-DD
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day);
    }

    if (timeframe == Timeframe::Hourly)
    {
        // hourly bucket: YYYY-MM-DD HH
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour);
    }

    if (timeframe == Timeframe::Minutely)
    {
        // minutely bucket: YYYY-MM-DD HH:MM
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour) + ":" + twoDigits(min);
    }

    if (timeframe == Timeframe::Secondly)
    {
        // secondly bucket: YYYY-MM-DD HH:MM:SS
        return std::to_string(year) + "-" + twoDigits(month) + "-" + twoDigits(day)
             + " " + twoDigits(hour) + ":" + twoDigits(min) + ":" + twoDigits(sec);
    }

    // fallback in case of unknown timeframe
    return timestamp;
}


==============================
FILE: MarketDataLoader.h
==============================
#pragma once
#include <vector>
#include <string>
#include <map>

#include "OrderBookEntry.h"
#include "Candlestick.h"

// time grouping options for task 1
enum class Timeframe {
    Daily,
    Monthly,
    Yearly,
    Hourly,    
    Minutely,  
    Secondly  
};

// personal implementation
// handles loading market data and computing candlestick summaries
class MarketDataLoader
{
public:
    // loads all market orders from the given csv file
    MarketDataLoader(const std::string& marketCSV);

    // filters by product and order type (ask / bid),
    // groups by timeframe, then computes candlesticks
    std::vector<Candlestick> computeCandlesticks(
        const std::string& product,
        OrderBookType type,
        Timeframe timeframe
    );

private:
    // holds all market orders loaded from the dataset
    std::vector<OrderBookEntry> orders;

    // converts a timestamp into the correct bucket string
    // depending on daily / monthly / yearly mode
    std::string getTimeBucket(const std::string& timestamp,
                              Timeframe timeframe);
};

==============================
FILE: OrderBookEntry.cpp
==============================
#include "OrderBookEntry.h"

// starter code – initializes a market order entry
OrderBookEntry::OrderBookEntry(double _price,
                               double _amount,
                               std::string _timestamp,
                               std::string _product,
                               OrderBookType _orderType,
                               std::string _username)
    : price(_price),
      amount(_amount),
      timestamp(_timestamp),
      product(_product),
      orderType(_orderType),
      username(_username)
{
    // nothing else to do here
}

// starter code – convert string from CSV → enum type
OrderBookType OrderBookEntry::stringToOrderBookType(std::string s) {
    if (s == "ask") {
        return OrderBookType::ask;
    }
    if (s == "bid") {
        return OrderBookType::bid;
    }
    // fallback for unknown/unsupported types
    return OrderBookType::unknown;
}

==============================
FILE: OrderBookEntry.h
==============================
#pragma once
#include <string>

// starter code – represents one market order
enum class OrderBookType { bid, ask, unknown, asksale, bidsale };

class OrderBookEntry {
public:
    // constructor – creates a trade/order object
    OrderBookEntry(double _price,
                   double _amount,
                   std::string _timestamp,
                   std::string _product,
                   OrderBookType _orderType,
                   std::string username = "dataset");

    // helper: convert string to enum
    static OrderBookType stringToOrderBookType(std::string s);

    // sorting helpers
    static bool compareByTimestamp(OrderBookEntry& e1, OrderBookEntry& e2) {
        // orders sorted earliest → latest
        return e1.timestamp < e2.timestamp;
    }

    static bool compareByPriceAsc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // low → high price
        return e1.price < e2.price;
    }

    static bool compareByPriceDesc(OrderBookEntry& e1, OrderBookEntry& e2) {
        // high → low price
        return e1.price > e2.price;
    }

    // core order properties
    double price;            // order price
    double amount;           // order amount
    std::string timestamp;   // string timestamp e.g. "2020-03-17 12:00:00"
    std::string product;     // product pair e.g. "ETH/USDT"
    OrderBookType orderType; // bid / ask / etc.
    std::string username;    // source of the order
};
